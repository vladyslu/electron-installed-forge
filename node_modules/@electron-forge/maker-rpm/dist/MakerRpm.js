"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "MakerRpmConfig", {
    enumerable: true,
    get: function() {
        return _config.MakerRpmConfig;
    }
});
exports.rpmArch = rpmArch;
exports.MakerRpm = exports.default = void 0;
var _path = _interopRequireDefault(require("path"));
var _makerBase = require("@electron-forge/maker-base");
var _config = require("./Config");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function rpmArch(nodeArch) {
    switch(nodeArch){
        case 'ia32':
            return 'i386';
        case 'x64':
            return 'x86_64';
        case 'armv7l':
            return 'armv7hl';
        case 'arm':
            return 'armv6hl';
        default:
            return nodeArch;
    }
}
class MakerRpm extends _makerBase.MakerBase {
    isSupportedOnCurrentPlatform() {
        return this.isInstalled('electron-installer-redhat');
    }
    async make({ dir , makeDir , targetArch  }) {
        // eslint-disable-next-line node/no-missing-require
        const installer = require('electron-installer-redhat');
        const outDir = _path.default.resolve(makeDir, 'rpm', targetArch);
        await this.ensureDirectory(outDir);
        const { packagePaths  } = await installer({
            ...this.config,
            arch: rpmArch(targetArch),
            src: dir,
            dest: outDir,
            rename: undefined
        });
        return packagePaths;
    }
    constructor(...args){
        super(...args);
        this.name = 'rpm';
        this.defaultPlatforms = [
            'linux'
        ];
        this.requiredExternalBinaries = [
            'rpmbuild'
        ];
    }
}
exports.default = MakerRpm;
exports.MakerRpm = MakerRpm;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9NYWtlclJwbS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcblxuaW1wb3J0IHsgTWFrZXJCYXNlLCBNYWtlck9wdGlvbnMgfSBmcm9tICdAZWxlY3Ryb24tZm9yZ2UvbWFrZXItYmFzZSc7XG5pbXBvcnQgeyBGb3JnZUFyY2gsIEZvcmdlUGxhdGZvcm0gfSBmcm9tICdAZWxlY3Ryb24tZm9yZ2Uvc2hhcmVkLXR5cGVzJztcblxuaW1wb3J0IHsgTWFrZXJScG1Db25maWcgfSBmcm9tICcuL0NvbmZpZyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBycG1BcmNoKG5vZGVBcmNoOiBGb3JnZUFyY2gpOiBzdHJpbmcge1xuICBzd2l0Y2ggKG5vZGVBcmNoKSB7XG4gICAgY2FzZSAnaWEzMic6XG4gICAgICByZXR1cm4gJ2kzODYnO1xuICAgIGNhc2UgJ3g2NCc6XG4gICAgICByZXR1cm4gJ3g4Nl82NCc7XG4gICAgY2FzZSAnYXJtdjdsJzpcbiAgICAgIHJldHVybiAnYXJtdjdobCc7XG4gICAgY2FzZSAnYXJtJzpcbiAgICAgIHJldHVybiAnYXJtdjZobCc7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBub2RlQXJjaDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYWtlclJwbSBleHRlbmRzIE1ha2VyQmFzZTxNYWtlclJwbUNvbmZpZz4ge1xuICBuYW1lID0gJ3JwbSc7XG5cbiAgZGVmYXVsdFBsYXRmb3JtczogRm9yZ2VQbGF0Zm9ybVtdID0gWydsaW51eCddO1xuXG4gIHJlcXVpcmVkRXh0ZXJuYWxCaW5hcmllczogc3RyaW5nW10gPSBbJ3JwbWJ1aWxkJ107XG5cbiAgaXNTdXBwb3J0ZWRPbkN1cnJlbnRQbGF0Zm9ybSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc0luc3RhbGxlZCgnZWxlY3Ryb24taW5zdGFsbGVyLXJlZGhhdCcpO1xuICB9XG5cbiAgYXN5bmMgbWFrZSh7IGRpciwgbWFrZURpciwgdGFyZ2V0QXJjaCB9OiBNYWtlck9wdGlvbnMpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tbWlzc2luZy1yZXF1aXJlXG4gICAgY29uc3QgaW5zdGFsbGVyID0gcmVxdWlyZSgnZWxlY3Ryb24taW5zdGFsbGVyLXJlZGhhdCcpO1xuXG4gICAgY29uc3Qgb3V0RGlyID0gcGF0aC5yZXNvbHZlKG1ha2VEaXIsICdycG0nLCB0YXJnZXRBcmNoKTtcblxuICAgIGF3YWl0IHRoaXMuZW5zdXJlRGlyZWN0b3J5KG91dERpcik7XG4gICAgY29uc3QgeyBwYWNrYWdlUGF0aHMgfSA9IGF3YWl0IGluc3RhbGxlcih7XG4gICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgIGFyY2g6IHJwbUFyY2godGFyZ2V0QXJjaCksXG4gICAgICBzcmM6IGRpcixcbiAgICAgIGRlc3Q6IG91dERpcixcbiAgICAgIHJlbmFtZTogdW5kZWZpbmVkLFxuICAgIH0pO1xuICAgIHJldHVybiBwYWNrYWdlUGF0aHM7XG4gIH1cbn1cblxuZXhwb3J0IHsgTWFrZXJScG0sIE1ha2VyUnBtQ29uZmlnIH07XG4iXSwibmFtZXMiOlsiTWFrZXJScG1Db25maWciLCJycG1BcmNoIiwibm9kZUFyY2giLCJNYWtlclJwbSIsIk1ha2VyQmFzZSIsImlzU3VwcG9ydGVkT25DdXJyZW50UGxhdGZvcm0iLCJpc0luc3RhbGxlZCIsIm1ha2UiLCJkaXIiLCJtYWtlRGlyIiwidGFyZ2V0QXJjaCIsImluc3RhbGxlciIsInJlcXVpcmUiLCJvdXREaXIiLCJwYXRoIiwicmVzb2x2ZSIsImVuc3VyZURpcmVjdG9yeSIsInBhY2thZ2VQYXRocyIsImNvbmZpZyIsImFyY2giLCJzcmMiLCJkZXN0IiwicmVuYW1lIiwidW5kZWZpbmVkIiwibmFtZSIsImRlZmF1bHRQbGF0Zm9ybXMiLCJyZXF1aXJlZEV4dGVybmFsQmluYXJpZXMiXSwibWFwcGluZ3MiOiI7Ozs7K0JBbURtQkEsQ0FBYzs7O2VBQWRBLE9BQWM7OztRQTVDakJDLE9BQU8sR0FBUEEsT0FBTzs7QUFQTixHQUFNLENBQU4sS0FBTTtBQUVpQixHQUE0QixDQUE1QixVQUE0QjtBQUdyQyxHQUFVLENBQVYsT0FBVTs7Ozs7O1NBRXpCQSxPQUFPLENBQUNDLFFBQW1CLEVBQVUsQ0FBQztJQUNwRCxNQUFNLENBQUVBLFFBQVE7UUFDZCxJQUFJLENBQUMsQ0FBTTtZQUNULE1BQU0sQ0FBQyxDQUFNO1FBQ2YsSUFBSSxDQUFDLENBQUs7WUFDUixNQUFNLENBQUMsQ0FBUTtRQUNqQixJQUFJLENBQUMsQ0FBUTtZQUNYLE1BQU0sQ0FBQyxDQUFTO1FBQ2xCLElBQUksQ0FBQyxDQUFLO1lBQ1IsTUFBTSxDQUFDLENBQVM7O1lBRWhCLE1BQU0sQ0FBQ0EsUUFBUTs7QUFFckIsQ0FBQztNQUVvQkMsUUFBUSxTQUFTQyxVQUFTO0lBTzdDQyw0QkFBNEIsR0FBWSxDQUFDO1FBQ3ZDLE1BQU0sQ0FBQyxJQUFJLENBQUNDLFdBQVcsQ0FBQyxDQUEyQjtJQUNyRCxDQUFDO1VBRUtDLElBQUksQ0FBQyxDQUFDLENBQUNDLEdBQUcsR0FBRUMsT0FBTyxHQUFFQyxVQUFVLEVBQWUsQ0FBQyxFQUFxQixDQUFDO1FBQ3pFLEVBQW1ELEFBQW5ELGlEQUFtRDtRQUNuRCxLQUFLLENBQUNDLFNBQVMsR0FBR0MsT0FBTyxDQUFDLENBQTJCO1FBRXJELEtBQUssQ0FBQ0MsTUFBTSxHQUFHQyxLQUFJLFNBQUNDLE9BQU8sQ0FBQ04sT0FBTyxFQUFFLENBQUssTUFBRUMsVUFBVTtRQUV0RCxLQUFLLENBQUMsSUFBSSxDQUFDTSxlQUFlLENBQUNILE1BQU07UUFDakMsS0FBSyxDQUFDLENBQUMsQ0FBQ0ksWUFBWSxFQUFDLENBQUMsR0FBRyxLQUFLLENBQUNOLFNBQVMsQ0FBQyxDQUFDO2VBQ3JDLElBQUksQ0FBQ08sTUFBTTtZQUNkQyxJQUFJLEVBQUVsQixPQUFPLENBQUNTLFVBQVU7WUFDeEJVLEdBQUcsRUFBRVosR0FBRztZQUNSYSxJQUFJLEVBQUVSLE1BQU07WUFDWlMsTUFBTSxFQUFFQyxTQUFTO1FBQ25CLENBQUM7UUFDRCxNQUFNLENBQUNOLFlBQVk7SUFDckIsQ0FBQzs7O1FBMUJZLElBMkJkLENBMUJDTyxJQUFJLEdBQUcsQ0FBSztRQURDLElBMkJkLENBeEJDQyxnQkFBZ0IsR0FBb0IsQ0FBQztZQUFBLENBQU87UUFBQSxDQUFDO1FBSGhDLElBMkJkLENBdEJDQyx3QkFBd0IsR0FBYSxDQUFDO1lBQUEsQ0FBVTtRQUFBLENBQUM7OztrQkFMOUJ2QixRQUFRO1FBNkJwQkEsUUFBUSxHQUFSQSxRQUFRIn0=