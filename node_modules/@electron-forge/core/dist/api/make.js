"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = exports.listrMake = void 0;
var _path = _interopRequireDefault(require("path"));
var _coreUtils = require("@electron-forge/core-utils");
var _makerBase = require("@electron-forge/maker-base");
var _get = require("@electron/get");
var _chalk = _interopRequireDefault(require("chalk"));
var _filenamify = _interopRequireDefault(require("filenamify"));
var _fsExtra = _interopRequireDefault(require("fs-extra"));
var _listr2 = require("listr2");
var _logSymbols = _interopRequireDefault(require("log-symbols"));
var _forgeConfig = _interopRequireDefault(require("../util/forge-config"));
var _hook = require("../util/hook");
var _outDir = _interopRequireDefault(require("../util/out-dir"));
var _parseArchs = _interopRequireDefault(require("../util/parse-archs"));
var _readPackageJson = require("../util/read-package-json");
var _requireSearch = _interopRequireDefault(require("../util/require-search"));
var _resolveDir = _interopRequireDefault(require("../util/resolve-dir"));
var _package = require("./package");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class MakerImpl extends _makerBase.MakerBase {
    constructor(...args){
        super(...args);
        this.name = 'impl';
        this.defaultPlatforms = [];
    }
}
function generateTargets(forgeConfig, overrideTargets) {
    if (overrideTargets) {
        return overrideTargets.map((target)=>{
            if (typeof target === 'string') {
                return forgeConfig.makers.find((maker)=>maker.name === target
                ) || {
                    name: target
                };
            }
            return target;
        });
    }
    return forgeConfig.makers;
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isElectronForgeMaker(target) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return target.__isElectronForgeMaker;
}
const listrMake = ({ dir: providedDir = process.cwd() , interactive =false , skipPackage =false , arch =(0, _get).getHostArch() , platform =process.platform , overrideTargets , outDir  }, receiveMakeResults)=>{
    const listrOptions = {
        concurrent: false,
        rendererOptions: {
            collapse: false,
            collapseErrors: false
        },
        rendererSilent: !interactive,
        rendererFallback: Boolean(process.env.DEBUG && process.env.DEBUG.includes('electron-forge'))
    };
    const runner = new _listr2.Listr([
        {
            title: 'Loading configuration',
            task: async (ctx)=>{
                const resolvedDir = await (0, _resolveDir).default(providedDir);
                if (!resolvedDir) {
                    throw new Error('Failed to locate startable Electron application');
                }
                ctx.dir = resolvedDir;
                ctx.forgeConfig = await (0, _forgeConfig).default(resolvedDir);
            }
        },
        {
            title: 'Resolving make targets',
            task: async (ctx, task)=>{
                const { dir , forgeConfig  } = ctx;
                ctx.actualOutDir = outDir || (0, _outDir).default(dir, forgeConfig);
                if (![
                    'darwin',
                    'win32',
                    'linux',
                    'mas'
                ].includes(platform)) {
                    throw new Error(`'${platform}' is an invalid platform. Choices are 'darwin', 'mas', 'win32' or 'linux'.`);
                }
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const makers = [];
                const possibleMakers = generateTargets(forgeConfig, overrideTargets);
                for (const possibleMaker of possibleMakers){
                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */ let maker;
                    if (isElectronForgeMaker(possibleMaker)) {
                        maker = possibleMaker;
                        if (!maker.platforms.includes(platform)) continue;
                    } else {
                        const resolvableTarget = possibleMaker;
                        // non-false falsy values should be 'true'
                        if (resolvableTarget.enabled === false) continue;
                        if (!resolvableTarget.name) {
                            throw new Error(`The following maker config is missing a maker name: ${JSON.stringify(resolvableTarget)}`);
                        } else if (typeof resolvableTarget.name !== 'string') {
                            throw new Error(`The following maker config has a maker name that is not a string: ${JSON.stringify(resolvableTarget)}`);
                        }
                        const MakerClass = (0, _requireSearch).default(dir, [
                            resolvableTarget.name
                        ]);
                        if (!MakerClass) {
                            throw new Error(`Could not find module with name '${resolvableTarget.name}'. If this is a package from NPM, make sure it's listed in the devDependencies of your package.json. If this is a local module, make sure you have the correct path to its entry point. Try using the DEBUG="electron-forge:require-search" environment variable for more information.`);
                        }
                        maker = new MakerClass(resolvableTarget.config, resolvableTarget.platforms || undefined);
                        if (!maker.platforms.includes(platform)) continue;
                    }
                    if (!maker.isSupportedOnCurrentPlatform) {
                        throw new Error([
                            `Maker for target ${maker.name} is incompatible with this version of `,
                            'Electron Forge, please upgrade or contact the maintainer ',
                            "(needs to implement 'isSupportedOnCurrentPlatform)')", 
                        ].join(''));
                    }
                    if (!maker.isSupportedOnCurrentPlatform()) {
                        throw new Error(`Cannot make for ${platform} and target ${maker.name}: the maker declared that it cannot run on ${process.platform}.`);
                    }
                    maker.ensureExternalBinariesExist();
                    makers.push(maker);
                }
                if (makers.length === 0) {
                    throw new Error(`Could not find any make targets configured for the "${platform}" platform.`);
                }
                ctx.makers = makers;
                task.output = `Making for the following targets: ${_chalk.default.magenta(`${makers.map((maker)=>maker.name
                ).join(', ')}`)}`;
            },
            options: {
                persistentOutput: true
            }
        },
        {
            title: `Running ${_chalk.default.yellow('package')} command`,
            task: async (ctx, task)=>{
                if (!skipPackage) {
                    return (0, _package).listrPackage({
                        dir: ctx.dir,
                        interactive,
                        arch,
                        outDir: ctx.actualOutDir,
                        platform
                    });
                } else {
                    task.output = _chalk.default.yellow(`${_logSymbols.default.warning} Skipping could result in an out of date build`);
                    task.skip();
                }
            },
            options: {
                persistentOutput: true
            }
        },
        {
            title: `Running ${_chalk.default.yellow('preMake')} hook`,
            task: async (ctx, task)=>{
                return task.newListr(await (0, _hook).getHookListrTasks(ctx.forgeConfig, 'preMake'));
            }
        },
        {
            title: 'Making distributables',
            task: async (ctx, task)=>{
                const { actualOutDir , dir , forgeConfig , makers  } = ctx;
                const packageJSON = await (0, _readPackageJson).readMutatedPackageJson(dir, forgeConfig);
                const appName = (0, _filenamify).default(forgeConfig.packagerConfig.name || packageJSON.productName || packageJSON.name, {
                    replacement: '-'
                });
                const outputs = [];
                ctx.outputs = outputs;
                const subRunner = task.newListr([], {
                    ...listrOptions,
                    rendererOptions: {
                        collapse: false,
                        collapseErrors: false
                    }
                });
                for (const targetArch of (0, _parseArchs).default(platform, arch, await (0, _coreUtils).getElectronVersion(dir, packageJSON))){
                    const packageDir = _path.default.resolve(actualOutDir, `${appName}-${platform}-${targetArch}`);
                    if (!await _fsExtra.default.pathExists(packageDir)) {
                        throw new Error(`Couldn't find packaged app at: ${packageDir}`);
                    }
                    for (const maker of makers){
                        subRunner.add({
                            title: `Making a ${_chalk.default.magenta(maker.name)} distributable for ${_chalk.default.cyan(`${platform}/${targetArch}`)}`,
                            task: async ()=>{
                                try {
                                    /**
                     * WARNING: DO NOT ATTEMPT TO PARALLELIZE MAKERS
                     *
                     * Currently it is assumed we have 1 maker per make call but that is
                     * not enforced.  It is technically possible to have 1 maker be called
                     * multiple times.  The "prepareConfig" method however implicitly
                     * requires a lock that is not enforced.  There are two options:
                     *
                     *   * Provide makers a getConfig() method
                     *   * Remove support for config being provided as a method
                     *   * Change the entire API of maker from a single constructor to
                     *     providing a MakerFactory
                     */ maker.prepareConfig(targetArch);
                                    const artifacts = await maker.make({
                                        appName,
                                        forgeConfig,
                                        packageJSON,
                                        targetArch,
                                        dir: packageDir,
                                        makeDir: _path.default.resolve(actualOutDir, 'make'),
                                        targetPlatform: platform
                                    });
                                    outputs.push({
                                        artifacts,
                                        packageJSON,
                                        platform,
                                        arch: targetArch
                                    });
                                } catch (err) {
                                    if (err instanceof Error) {
                                        throw {
                                            message: `An error occured while making for target: ${maker.name}`,
                                            stack: `${err.message}\n${err.stack}`
                                        };
                                    } else if (err) {
                                        throw err;
                                    } else {
                                        throw new Error(`An unknown error occured while making for target: ${maker.name}`);
                                    }
                                }
                            },
                            options: {
                                showTimer: true
                            }
                        });
                    }
                }
                return subRunner;
            }
        },
        {
            title: `Running ${_chalk.default.yellow('postMake')} hook`,
            task: async (ctx, task)=>{
                // If the postMake hooks modifies the locations / names of the outputs it must return
                // the new locations so that the publish step knows where to look
                ctx.outputs = await (0, _hook).runMutatingHook(ctx.forgeConfig, 'postMake', ctx.outputs);
                receiveMakeResults === null || receiveMakeResults === void 0 ? void 0 : receiveMakeResults(ctx.outputs);
                task.output = `Artifacts available at: ${_chalk.default.green(_path.default.resolve(ctx.actualOutDir, 'make'))}`;
            },
            options: {
                persistentOutput: true
            }
        }, 
    ], {
        ...listrOptions,
        ctx: {}
    });
    return runner;
};
exports.listrMake = listrMake;
const make = async (opts)=>{
    const runner = listrMake(opts);
    await runner.run();
    return runner.ctx.outputs;
};
var _default = make;
exports.default = _default;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hcGkvbWFrZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcblxuaW1wb3J0IHsgZ2V0RWxlY3Ryb25WZXJzaW9uIH0gZnJvbSAnQGVsZWN0cm9uLWZvcmdlL2NvcmUtdXRpbHMnO1xuaW1wb3J0IHsgTWFrZXJCYXNlIH0gZnJvbSAnQGVsZWN0cm9uLWZvcmdlL21ha2VyLWJhc2UnO1xuaW1wb3J0IHsgRm9yZ2VBcmNoLCBGb3JnZUNvbmZpZ01ha2VyLCBGb3JnZU1ha2VSZXN1bHQsIEZvcmdlUGxhdGZvcm0sIElGb3JnZVJlc29sdmFibGVNYWtlciwgUmVzb2x2ZWRGb3JnZUNvbmZpZyB9IGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9zaGFyZWQtdHlwZXMnO1xuaW1wb3J0IHsgZ2V0SG9zdEFyY2ggfSBmcm9tICdAZWxlY3Ryb24vZ2V0JztcbmltcG9ydCBjaGFsayBmcm9tICdjaGFsayc7XG5pbXBvcnQgZmlsZW5hbWlmeSBmcm9tICdmaWxlbmFtaWZ5JztcbmltcG9ydCBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgeyBMaXN0ciB9IGZyb20gJ2xpc3RyMic7XG5pbXBvcnQgbG9nU3ltYm9scyBmcm9tICdsb2ctc3ltYm9scyc7XG5cbmltcG9ydCBnZXRGb3JnZUNvbmZpZyBmcm9tICcuLi91dGlsL2ZvcmdlLWNvbmZpZyc7XG5pbXBvcnQgeyBnZXRIb29rTGlzdHJUYXNrcywgcnVuTXV0YXRpbmdIb29rIH0gZnJvbSAnLi4vdXRpbC9ob29rJztcbmltcG9ydCBnZXRDdXJyZW50T3V0RGlyIGZyb20gJy4uL3V0aWwvb3V0LWRpcic7XG5pbXBvcnQgcGFyc2VBcmNocyBmcm9tICcuLi91dGlsL3BhcnNlLWFyY2hzJztcbmltcG9ydCB7IHJlYWRNdXRhdGVkUGFja2FnZUpzb24gfSBmcm9tICcuLi91dGlsL3JlYWQtcGFja2FnZS1qc29uJztcbmltcG9ydCByZXF1aXJlU2VhcmNoIGZyb20gJy4uL3V0aWwvcmVxdWlyZS1zZWFyY2gnO1xuaW1wb3J0IHJlc29sdmVEaXIgZnJvbSAnLi4vdXRpbC9yZXNvbHZlLWRpcic7XG5cbmltcG9ydCB7IGxpc3RyUGFja2FnZSB9IGZyb20gJy4vcGFja2FnZSc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jbGFzcyBNYWtlckltcGwgZXh0ZW5kcyBNYWtlckJhc2U8YW55PiB7XG4gIG5hbWUgPSAnaW1wbCc7XG5cbiAgZGVmYXVsdFBsYXRmb3JtcyA9IFtdO1xufVxuXG50eXBlIE1ha2VUYXJnZXRzID0gRm9yZ2VDb25maWdNYWtlcltdIHwgc3RyaW5nW107XG5cbmZ1bmN0aW9uIGdlbmVyYXRlVGFyZ2V0cyhmb3JnZUNvbmZpZzogUmVzb2x2ZWRGb3JnZUNvbmZpZywgb3ZlcnJpZGVUYXJnZXRzPzogTWFrZVRhcmdldHMpIHtcbiAgaWYgKG92ZXJyaWRlVGFyZ2V0cykge1xuICAgIHJldHVybiBvdmVycmlkZVRhcmdldHMubWFwKCh0YXJnZXQpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZm9yZ2VDb25maWcubWFrZXJzLmZpbmQoKG1ha2VyKSA9PiAobWFrZXIgYXMgSUZvcmdlUmVzb2x2YWJsZU1ha2VyKS5uYW1lID09PSB0YXJnZXQpIHx8ICh7IG5hbWU6IHRhcmdldCB9IGFzIElGb3JnZVJlc29sdmFibGVNYWtlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGZvcmdlQ29uZmlnLm1ha2Vycztcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGlzRWxlY3Ryb25Gb3JnZU1ha2VyKHRhcmdldDogTWFrZXJCYXNlPGFueT4gfCB1bmtub3duKTogdGFyZ2V0IGlzIE1ha2VyQmFzZTxhbnk+IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgcmV0dXJuICh0YXJnZXQgYXMgTWFrZXJCYXNlPGFueT4pLl9faXNFbGVjdHJvbkZvcmdlTWFrZXI7XG59XG5cbnR5cGUgTWFrZUNvbnRleHQgPSB7XG4gIGRpcjogc3RyaW5nO1xuICBmb3JnZUNvbmZpZzogUmVzb2x2ZWRGb3JnZUNvbmZpZztcbiAgYWN0dWFsT3V0RGlyOiBzdHJpbmc7XG4gIG1ha2VyczogTWFrZXJCYXNlPHVua25vd24+W107XG4gIG91dHB1dHM6IEZvcmdlTWFrZVJlc3VsdFtdO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBNYWtlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgcGF0aCB0byB0aGUgYXBwIGZyb20gd2hpY2ggZGlzdHJ1YnV0YWJsZXMgYXJlIGdlbmVyYXRlZFxuICAgKi9cbiAgZGlyPzogc3RyaW5nO1xuICAvKipcbiAgICogV2hldGhlciB0byB1c2Ugc2Vuc2libGUgZGVmYXVsdHMgb3IgcHJvbXB0IHRoZSB1c2VyIHZpc3VhbGx5XG4gICAqL1xuICBpbnRlcmFjdGl2ZT86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHNraXAgdGhlIHByZS1tYWtlIHBhY2thZ2luZyBzdGVwXG4gICAqL1xuICBza2lwUGFja2FnZT86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBtYWtlIHRhcmdldHMgdG8gb3ZlcnJpZGUgeW91ciBmb3JnZSBjb25maWdcbiAgICovXG4gIG92ZXJyaWRlVGFyZ2V0cz86IE1ha2VUYXJnZXRzO1xuICAvKipcbiAgICogVGhlIHRhcmdldCBhcmNoaXRlY3R1cmVcbiAgICovXG4gIGFyY2g/OiBGb3JnZUFyY2g7XG4gIC8qKlxuICAgKiBUaGUgdGFyZ2V0IHBsYXRmb3JtXG4gICAqL1xuICBwbGF0Zm9ybT86IEZvcmdlUGxhdGZvcm07XG4gIC8qKlxuICAgKiBUaGUgcGF0aCB0byB0aGUgZGlyZWN0b3J5IGNvbnRhaW5pbmcgZ2VuZXJhdGVkIGRpc3RyaWJ1dGFibGVzXG4gICAqL1xuICBvdXREaXI/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBsaXN0ck1ha2UgPSAoXG4gIHtcbiAgICBkaXI6IHByb3ZpZGVkRGlyID0gcHJvY2Vzcy5jd2QoKSxcbiAgICBpbnRlcmFjdGl2ZSA9IGZhbHNlLFxuICAgIHNraXBQYWNrYWdlID0gZmFsc2UsXG4gICAgYXJjaCA9IGdldEhvc3RBcmNoKCkgYXMgRm9yZ2VBcmNoLFxuICAgIHBsYXRmb3JtID0gcHJvY2Vzcy5wbGF0Zm9ybSBhcyBGb3JnZVBsYXRmb3JtLFxuICAgIG92ZXJyaWRlVGFyZ2V0cyxcbiAgICBvdXREaXIsXG4gIH06IE1ha2VPcHRpb25zLFxuICByZWNlaXZlTWFrZVJlc3VsdHM/OiAocmVzdWx0czogRm9yZ2VNYWtlUmVzdWx0W10pID0+IHZvaWRcbikgPT4ge1xuICBjb25zdCBsaXN0ck9wdGlvbnMgPSB7XG4gICAgY29uY3VycmVudDogZmFsc2UsXG4gICAgcmVuZGVyZXJPcHRpb25zOiB7XG4gICAgICBjb2xsYXBzZTogZmFsc2UsXG4gICAgICBjb2xsYXBzZUVycm9yczogZmFsc2UsXG4gICAgfSxcbiAgICByZW5kZXJlclNpbGVudDogIWludGVyYWN0aXZlLFxuICAgIHJlbmRlcmVyRmFsbGJhY2s6IEJvb2xlYW4ocHJvY2Vzcy5lbnYuREVCVUcgJiYgcHJvY2Vzcy5lbnYuREVCVUcuaW5jbHVkZXMoJ2VsZWN0cm9uLWZvcmdlJykpLFxuICB9O1xuXG4gIGNvbnN0IHJ1bm5lciA9IG5ldyBMaXN0cjxNYWtlQ29udGV4dD4oXG4gICAgW1xuICAgICAge1xuICAgICAgICB0aXRsZTogJ0xvYWRpbmcgY29uZmlndXJhdGlvbicsXG4gICAgICAgIHRhc2s6IGFzeW5jIChjdHgpID0+IHtcbiAgICAgICAgICBjb25zdCByZXNvbHZlZERpciA9IGF3YWl0IHJlc29sdmVEaXIocHJvdmlkZWREaXIpO1xuICAgICAgICAgIGlmICghcmVzb2x2ZWREaXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGxvY2F0ZSBzdGFydGFibGUgRWxlY3Ryb24gYXBwbGljYXRpb24nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdHguZGlyID0gcmVzb2x2ZWREaXI7XG4gICAgICAgICAgY3R4LmZvcmdlQ29uZmlnID0gYXdhaXQgZ2V0Rm9yZ2VDb25maWcocmVzb2x2ZWREaXIpO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdGl0bGU6ICdSZXNvbHZpbmcgbWFrZSB0YXJnZXRzJyxcbiAgICAgICAgdGFzazogYXN5bmMgKGN0eCwgdGFzaykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgZGlyLCBmb3JnZUNvbmZpZyB9ID0gY3R4O1xuICAgICAgICAgIGN0eC5hY3R1YWxPdXREaXIgPSBvdXREaXIgfHwgZ2V0Q3VycmVudE91dERpcihkaXIsIGZvcmdlQ29uZmlnKTtcblxuICAgICAgICAgIGlmICghWydkYXJ3aW4nLCAnd2luMzInLCAnbGludXgnLCAnbWFzJ10uaW5jbHVkZXMocGxhdGZvcm0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCcke3BsYXRmb3JtfScgaXMgYW4gaW52YWxpZCBwbGF0Zm9ybS4gQ2hvaWNlcyBhcmUgJ2RhcndpbicsICdtYXMnLCAnd2luMzInIG9yICdsaW51eCcuYCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICBjb25zdCBtYWtlcnM6IE1ha2VyQmFzZTxhbnk+W10gPSBbXTtcblxuICAgICAgICAgIGNvbnN0IHBvc3NpYmxlTWFrZXJzID0gZ2VuZXJhdGVUYXJnZXRzKGZvcmdlQ29uZmlnLCBvdmVycmlkZVRhcmdldHMpO1xuXG4gICAgICAgICAgZm9yIChjb25zdCBwb3NzaWJsZU1ha2VyIG9mIHBvc3NpYmxlTWFrZXJzKSB7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuICAgICAgICAgICAgbGV0IG1ha2VyOiBNYWtlckJhc2U8YW55PjtcbiAgICAgICAgICAgIGlmIChpc0VsZWN0cm9uRm9yZ2VNYWtlcihwb3NzaWJsZU1ha2VyKSkge1xuICAgICAgICAgICAgICBtYWtlciA9IHBvc3NpYmxlTWFrZXI7XG4gICAgICAgICAgICAgIGlmICghbWFrZXIucGxhdGZvcm1zLmluY2x1ZGVzKHBsYXRmb3JtKSkgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCByZXNvbHZhYmxlVGFyZ2V0ID0gcG9zc2libGVNYWtlciBhcyBJRm9yZ2VSZXNvbHZhYmxlTWFrZXI7XG4gICAgICAgICAgICAgIC8vIG5vbi1mYWxzZSBmYWxzeSB2YWx1ZXMgc2hvdWxkIGJlICd0cnVlJ1xuICAgICAgICAgICAgICBpZiAocmVzb2x2YWJsZVRhcmdldC5lbmFibGVkID09PSBmYWxzZSkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgaWYgKCFyZXNvbHZhYmxlVGFyZ2V0Lm5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBmb2xsb3dpbmcgbWFrZXIgY29uZmlnIGlzIG1pc3NpbmcgYSBtYWtlciBuYW1lOiAke0pTT04uc3RyaW5naWZ5KHJlc29sdmFibGVUYXJnZXQpfWApO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXNvbHZhYmxlVGFyZ2V0Lm5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZm9sbG93aW5nIG1ha2VyIGNvbmZpZyBoYXMgYSBtYWtlciBuYW1lIHRoYXQgaXMgbm90IGEgc3RyaW5nOiAke0pTT04uc3RyaW5naWZ5KHJlc29sdmFibGVUYXJnZXQpfWApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29uc3QgTWFrZXJDbGFzcyA9IHJlcXVpcmVTZWFyY2g8dHlwZW9mIE1ha2VySW1wbD4oZGlyLCBbcmVzb2x2YWJsZVRhcmdldC5uYW1lXSk7XG4gICAgICAgICAgICAgIGlmICghTWFrZXJDbGFzcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgIGBDb3VsZCBub3QgZmluZCBtb2R1bGUgd2l0aCBuYW1lICcke3Jlc29sdmFibGVUYXJnZXQubmFtZX0nLiBJZiB0aGlzIGlzIGEgcGFja2FnZSBmcm9tIE5QTSwgbWFrZSBzdXJlIGl0J3MgbGlzdGVkIGluIHRoZSBkZXZEZXBlbmRlbmNpZXMgb2YgeW91ciBwYWNrYWdlLmpzb24uIElmIHRoaXMgaXMgYSBsb2NhbCBtb2R1bGUsIG1ha2Ugc3VyZSB5b3UgaGF2ZSB0aGUgY29ycmVjdCBwYXRoIHRvIGl0cyBlbnRyeSBwb2ludC4gVHJ5IHVzaW5nIHRoZSBERUJVRz1cImVsZWN0cm9uLWZvcmdlOnJlcXVpcmUtc2VhcmNoXCIgZW52aXJvbm1lbnQgdmFyaWFibGUgZm9yIG1vcmUgaW5mb3JtYXRpb24uYFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBtYWtlciA9IG5ldyBNYWtlckNsYXNzKHJlc29sdmFibGVUYXJnZXQuY29uZmlnLCByZXNvbHZhYmxlVGFyZ2V0LnBsYXRmb3JtcyB8fCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICBpZiAoIW1ha2VyLnBsYXRmb3Jtcy5pbmNsdWRlcyhwbGF0Zm9ybSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW1ha2VyLmlzU3VwcG9ydGVkT25DdXJyZW50UGxhdGZvcm0pIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgIGBNYWtlciBmb3IgdGFyZ2V0ICR7bWFrZXIubmFtZX0gaXMgaW5jb21wYXRpYmxlIHdpdGggdGhpcyB2ZXJzaW9uIG9mIGAsXG4gICAgICAgICAgICAgICAgICAnRWxlY3Ryb24gRm9yZ2UsIHBsZWFzZSB1cGdyYWRlIG9yIGNvbnRhY3QgdGhlIG1haW50YWluZXIgJyxcbiAgICAgICAgICAgICAgICAgIFwiKG5lZWRzIHRvIGltcGxlbWVudCAnaXNTdXBwb3J0ZWRPbkN1cnJlbnRQbGF0Zm9ybSknKVwiLFxuICAgICAgICAgICAgICAgIF0uam9pbignJylcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFtYWtlci5pc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtKCkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgbWFrZSBmb3IgJHtwbGF0Zm9ybX0gYW5kIHRhcmdldCAke21ha2VyLm5hbWV9OiB0aGUgbWFrZXIgZGVjbGFyZWQgdGhhdCBpdCBjYW5ub3QgcnVuIG9uICR7cHJvY2Vzcy5wbGF0Zm9ybX0uYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1ha2VyLmVuc3VyZUV4dGVybmFsQmluYXJpZXNFeGlzdCgpO1xuXG4gICAgICAgICAgICBtYWtlcnMucHVzaChtYWtlcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1ha2Vycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgYW55IG1ha2UgdGFyZ2V0cyBjb25maWd1cmVkIGZvciB0aGUgXCIke3BsYXRmb3JtfVwiIHBsYXRmb3JtLmApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN0eC5tYWtlcnMgPSBtYWtlcnM7XG5cbiAgICAgICAgICB0YXNrLm91dHB1dCA9IGBNYWtpbmcgZm9yIHRoZSBmb2xsb3dpbmcgdGFyZ2V0czogJHtjaGFsay5tYWdlbnRhKGAke21ha2Vycy5tYXAoKG1ha2VyKSA9PiBtYWtlci5uYW1lKS5qb2luKCcsICcpfWApfWA7XG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBwZXJzaXN0ZW50T3V0cHV0OiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdGl0bGU6IGBSdW5uaW5nICR7Y2hhbGsueWVsbG93KCdwYWNrYWdlJyl9IGNvbW1hbmRgLFxuICAgICAgICB0YXNrOiBhc3luYyAoY3R4LCB0YXNrKSA9PiB7XG4gICAgICAgICAgaWYgKCFza2lwUGFja2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxpc3RyUGFja2FnZSh7XG4gICAgICAgICAgICAgIGRpcjogY3R4LmRpcixcbiAgICAgICAgICAgICAgaW50ZXJhY3RpdmUsXG4gICAgICAgICAgICAgIGFyY2gsXG4gICAgICAgICAgICAgIG91dERpcjogY3R4LmFjdHVhbE91dERpcixcbiAgICAgICAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFzay5vdXRwdXQgPSBjaGFsay55ZWxsb3coYCR7bG9nU3ltYm9scy53YXJuaW5nfSBTa2lwcGluZyBjb3VsZCByZXN1bHQgaW4gYW4gb3V0IG9mIGRhdGUgYnVpbGRgKTtcbiAgICAgICAgICAgIHRhc2suc2tpcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIHBlcnNpc3RlbnRPdXRwdXQ6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0aXRsZTogYFJ1bm5pbmcgJHtjaGFsay55ZWxsb3coJ3ByZU1ha2UnKX0gaG9va2AsXG4gICAgICAgIHRhc2s6IGFzeW5jIChjdHgsIHRhc2spID0+IHtcbiAgICAgICAgICByZXR1cm4gdGFzay5uZXdMaXN0cihhd2FpdCBnZXRIb29rTGlzdHJUYXNrcyhjdHguZm9yZ2VDb25maWcsICdwcmVNYWtlJykpO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdGl0bGU6ICdNYWtpbmcgZGlzdHJpYnV0YWJsZXMnLFxuICAgICAgICB0YXNrOiBhc3luYyAoY3R4LCB0YXNrKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBhY3R1YWxPdXREaXIsIGRpciwgZm9yZ2VDb25maWcsIG1ha2VycyB9ID0gY3R4O1xuICAgICAgICAgIGNvbnN0IHBhY2thZ2VKU09OID0gYXdhaXQgcmVhZE11dGF0ZWRQYWNrYWdlSnNvbihkaXIsIGZvcmdlQ29uZmlnKTtcbiAgICAgICAgICBjb25zdCBhcHBOYW1lID0gZmlsZW5hbWlmeShmb3JnZUNvbmZpZy5wYWNrYWdlckNvbmZpZy5uYW1lIHx8IHBhY2thZ2VKU09OLnByb2R1Y3ROYW1lIHx8IHBhY2thZ2VKU09OLm5hbWUsIHsgcmVwbGFjZW1lbnQ6ICctJyB9KTtcbiAgICAgICAgICBjb25zdCBvdXRwdXRzOiBGb3JnZU1ha2VSZXN1bHRbXSA9IFtdO1xuICAgICAgICAgIGN0eC5vdXRwdXRzID0gb3V0cHV0cztcblxuICAgICAgICAgIGNvbnN0IHN1YlJ1bm5lciA9IHRhc2submV3TGlzdHIoW10sIHtcbiAgICAgICAgICAgIC4uLmxpc3RyT3B0aW9ucyxcbiAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9uczoge1xuICAgICAgICAgICAgICBjb2xsYXBzZTogZmFsc2UsXG4gICAgICAgICAgICAgIGNvbGxhcHNlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IHRhcmdldEFyY2ggb2YgcGFyc2VBcmNocyhwbGF0Zm9ybSwgYXJjaCwgYXdhaXQgZ2V0RWxlY3Ryb25WZXJzaW9uKGRpciwgcGFja2FnZUpTT04pKSkge1xuICAgICAgICAgICAgY29uc3QgcGFja2FnZURpciA9IHBhdGgucmVzb2x2ZShhY3R1YWxPdXREaXIsIGAke2FwcE5hbWV9LSR7cGxhdGZvcm19LSR7dGFyZ2V0QXJjaH1gKTtcbiAgICAgICAgICAgIGlmICghKGF3YWl0IGZzLnBhdGhFeGlzdHMocGFja2FnZURpcikpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGRuJ3QgZmluZCBwYWNrYWdlZCBhcHAgYXQ6ICR7cGFja2FnZURpcn1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChjb25zdCBtYWtlciBvZiBtYWtlcnMpIHtcbiAgICAgICAgICAgICAgc3ViUnVubmVyLmFkZCh7XG4gICAgICAgICAgICAgICAgdGl0bGU6IGBNYWtpbmcgYSAke2NoYWxrLm1hZ2VudGEobWFrZXIubmFtZSl9IGRpc3RyaWJ1dGFibGUgZm9yICR7Y2hhbGsuY3lhbihgJHtwbGF0Zm9ybX0vJHt0YXJnZXRBcmNofWApfWAsXG4gICAgICAgICAgICAgICAgdGFzazogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIFdBUk5JTkc6IERPIE5PVCBBVFRFTVBUIFRPIFBBUkFMTEVMSVpFIE1BS0VSU1xuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiBDdXJyZW50bHkgaXQgaXMgYXNzdW1lZCB3ZSBoYXZlIDEgbWFrZXIgcGVyIG1ha2UgY2FsbCBidXQgdGhhdCBpc1xuICAgICAgICAgICAgICAgICAgICAgKiBub3QgZW5mb3JjZWQuICBJdCBpcyB0ZWNobmljYWxseSBwb3NzaWJsZSB0byBoYXZlIDEgbWFrZXIgYmUgY2FsbGVkXG4gICAgICAgICAgICAgICAgICAgICAqIG11bHRpcGxlIHRpbWVzLiAgVGhlIFwicHJlcGFyZUNvbmZpZ1wiIG1ldGhvZCBob3dldmVyIGltcGxpY2l0bHlcbiAgICAgICAgICAgICAgICAgICAgICogcmVxdWlyZXMgYSBsb2NrIHRoYXQgaXMgbm90IGVuZm9yY2VkLiAgVGhlcmUgYXJlIHR3byBvcHRpb25zOlxuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiAgICogUHJvdmlkZSBtYWtlcnMgYSBnZXRDb25maWcoKSBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgICogICAqIFJlbW92ZSBzdXBwb3J0IGZvciBjb25maWcgYmVpbmcgcHJvdmlkZWQgYXMgYSBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgICogICAqIENoYW5nZSB0aGUgZW50aXJlIEFQSSBvZiBtYWtlciBmcm9tIGEgc2luZ2xlIGNvbnN0cnVjdG9yIHRvXG4gICAgICAgICAgICAgICAgICAgICAqICAgICBwcm92aWRpbmcgYSBNYWtlckZhY3RvcnlcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIG1ha2VyLnByZXBhcmVDb25maWcodGFyZ2V0QXJjaCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFydGlmYWN0cyA9IGF3YWl0IG1ha2VyLm1ha2Uoe1xuICAgICAgICAgICAgICAgICAgICAgIGFwcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgZm9yZ2VDb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgcGFja2FnZUpTT04sXG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0QXJjaCxcbiAgICAgICAgICAgICAgICAgICAgICBkaXI6IHBhY2thZ2VEaXIsXG4gICAgICAgICAgICAgICAgICAgICAgbWFrZURpcjogcGF0aC5yZXNvbHZlKGFjdHVhbE91dERpciwgJ21ha2UnKSxcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRQbGF0Zm9ybTogcGxhdGZvcm0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgYXJ0aWZhY3RzLFxuICAgICAgICAgICAgICAgICAgICAgIHBhY2thZ2VKU09OLFxuICAgICAgICAgICAgICAgICAgICAgIHBsYXRmb3JtLFxuICAgICAgICAgICAgICAgICAgICAgIGFyY2g6IHRhcmdldEFyY2gsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBBbiBlcnJvciBvY2N1cmVkIHdoaWxlIG1ha2luZyBmb3IgdGFyZ2V0OiAke21ha2VyLm5hbWV9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiBgJHtlcnIubWVzc2FnZX1cXG4ke2Vyci5zdGFja31gLFxuICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW4gdW5rbm93biBlcnJvciBvY2N1cmVkIHdoaWxlIG1ha2luZyBmb3IgdGFyZ2V0OiAke21ha2VyLm5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgIHNob3dUaW1lcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3ViUnVubmVyO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdGl0bGU6IGBSdW5uaW5nICR7Y2hhbGsueWVsbG93KCdwb3N0TWFrZScpfSBob29rYCxcbiAgICAgICAgdGFzazogYXN5bmMgKGN0eCwgdGFzaykgPT4ge1xuICAgICAgICAgIC8vIElmIHRoZSBwb3N0TWFrZSBob29rcyBtb2RpZmllcyB0aGUgbG9jYXRpb25zIC8gbmFtZXMgb2YgdGhlIG91dHB1dHMgaXQgbXVzdCByZXR1cm5cbiAgICAgICAgICAvLyB0aGUgbmV3IGxvY2F0aW9ucyBzbyB0aGF0IHRoZSBwdWJsaXNoIHN0ZXAga25vd3Mgd2hlcmUgdG8gbG9va1xuICAgICAgICAgIGN0eC5vdXRwdXRzID0gYXdhaXQgcnVuTXV0YXRpbmdIb29rKGN0eC5mb3JnZUNvbmZpZywgJ3Bvc3RNYWtlJywgY3R4Lm91dHB1dHMpO1xuICAgICAgICAgIHJlY2VpdmVNYWtlUmVzdWx0cz8uKGN0eC5vdXRwdXRzKTtcblxuICAgICAgICAgIHRhc2sub3V0cHV0ID0gYEFydGlmYWN0cyBhdmFpbGFibGUgYXQ6ICR7Y2hhbGsuZ3JlZW4ocGF0aC5yZXNvbHZlKGN0eC5hY3R1YWxPdXREaXIsICdtYWtlJykpfWA7XG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBwZXJzaXN0ZW50T3V0cHV0OiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICBdLFxuICAgIHtcbiAgICAgIC4uLmxpc3RyT3B0aW9ucyxcbiAgICAgIGN0eDoge30gYXMgTWFrZUNvbnRleHQsXG4gICAgfVxuICApO1xuXG4gIHJldHVybiBydW5uZXI7XG59O1xuXG5jb25zdCBtYWtlID0gYXN5bmMgKG9wdHM6IE1ha2VPcHRpb25zKTogUHJvbWlzZTxGb3JnZU1ha2VSZXN1bHRbXT4gPT4ge1xuICBjb25zdCBydW5uZXIgPSBsaXN0ck1ha2Uob3B0cyk7XG5cbiAgYXdhaXQgcnVubmVyLnJ1bigpO1xuXG4gIHJldHVybiBydW5uZXIuY3R4Lm91dHB1dHM7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBtYWtlO1xuIl0sIm5hbWVzIjpbIk1ha2VySW1wbCIsIk1ha2VyQmFzZSIsIm5hbWUiLCJkZWZhdWx0UGxhdGZvcm1zIiwiZ2VuZXJhdGVUYXJnZXRzIiwiZm9yZ2VDb25maWciLCJvdmVycmlkZVRhcmdldHMiLCJtYXAiLCJ0YXJnZXQiLCJtYWtlcnMiLCJmaW5kIiwibWFrZXIiLCJpc0VsZWN0cm9uRm9yZ2VNYWtlciIsIl9faXNFbGVjdHJvbkZvcmdlTWFrZXIiLCJsaXN0ck1ha2UiLCJkaXIiLCJwcm92aWRlZERpciIsInByb2Nlc3MiLCJjd2QiLCJpbnRlcmFjdGl2ZSIsInNraXBQYWNrYWdlIiwiYXJjaCIsImdldEhvc3RBcmNoIiwicGxhdGZvcm0iLCJvdXREaXIiLCJyZWNlaXZlTWFrZVJlc3VsdHMiLCJsaXN0ck9wdGlvbnMiLCJjb25jdXJyZW50IiwicmVuZGVyZXJPcHRpb25zIiwiY29sbGFwc2UiLCJjb2xsYXBzZUVycm9ycyIsInJlbmRlcmVyU2lsZW50IiwicmVuZGVyZXJGYWxsYmFjayIsIkJvb2xlYW4iLCJlbnYiLCJERUJVRyIsImluY2x1ZGVzIiwicnVubmVyIiwiTGlzdHIiLCJ0aXRsZSIsInRhc2siLCJjdHgiLCJyZXNvbHZlZERpciIsInJlc29sdmVEaXIiLCJFcnJvciIsImdldEZvcmdlQ29uZmlnIiwiYWN0dWFsT3V0RGlyIiwiZ2V0Q3VycmVudE91dERpciIsInBvc3NpYmxlTWFrZXJzIiwicG9zc2libGVNYWtlciIsInBsYXRmb3JtcyIsInJlc29sdmFibGVUYXJnZXQiLCJlbmFibGVkIiwiSlNPTiIsInN0cmluZ2lmeSIsIk1ha2VyQ2xhc3MiLCJyZXF1aXJlU2VhcmNoIiwiY29uZmlnIiwidW5kZWZpbmVkIiwiaXNTdXBwb3J0ZWRPbkN1cnJlbnRQbGF0Zm9ybSIsImpvaW4iLCJlbnN1cmVFeHRlcm5hbEJpbmFyaWVzRXhpc3QiLCJwdXNoIiwibGVuZ3RoIiwib3V0cHV0IiwiY2hhbGsiLCJtYWdlbnRhIiwib3B0aW9ucyIsInBlcnNpc3RlbnRPdXRwdXQiLCJ5ZWxsb3ciLCJsaXN0clBhY2thZ2UiLCJsb2dTeW1ib2xzIiwid2FybmluZyIsInNraXAiLCJuZXdMaXN0ciIsImdldEhvb2tMaXN0clRhc2tzIiwicGFja2FnZUpTT04iLCJyZWFkTXV0YXRlZFBhY2thZ2VKc29uIiwiYXBwTmFtZSIsImZpbGVuYW1pZnkiLCJwYWNrYWdlckNvbmZpZyIsInByb2R1Y3ROYW1lIiwicmVwbGFjZW1lbnQiLCJvdXRwdXRzIiwic3ViUnVubmVyIiwidGFyZ2V0QXJjaCIsInBhcnNlQXJjaHMiLCJnZXRFbGVjdHJvblZlcnNpb24iLCJwYWNrYWdlRGlyIiwicGF0aCIsInJlc29sdmUiLCJmcyIsInBhdGhFeGlzdHMiLCJhZGQiLCJjeWFuIiwicHJlcGFyZUNvbmZpZyIsImFydGlmYWN0cyIsIm1ha2UiLCJtYWtlRGlyIiwidGFyZ2V0UGxhdGZvcm0iLCJlcnIiLCJtZXNzYWdlIiwic3RhY2siLCJzaG93VGltZXIiLCJydW5NdXRhdGluZ0hvb2siLCJncmVlbiIsIm9wdHMiLCJydW4iXSwibWFwcGluZ3MiOiI7Ozs7O0FBQWlCLEdBQU0sQ0FBTixLQUFNO0FBRVksR0FBNEIsQ0FBNUIsVUFBNEI7QUFDckMsR0FBNEIsQ0FBNUIsVUFBNEI7QUFFMUIsR0FBZSxDQUFmLElBQWU7QUFDekIsR0FBTyxDQUFQLE1BQU87QUFDRixHQUFZLENBQVosV0FBWTtBQUNwQixHQUFVLENBQVYsUUFBVTtBQUNILEdBQVEsQ0FBUixPQUFRO0FBQ1AsR0FBYSxDQUFiLFdBQWE7QUFFVCxHQUFzQixDQUF0QixZQUFzQjtBQUNFLEdBQWMsQ0FBZCxLQUFjO0FBQ3BDLEdBQWlCLENBQWpCLE9BQWlCO0FBQ3ZCLEdBQXFCLENBQXJCLFdBQXFCO0FBQ0wsR0FBMkIsQ0FBM0IsZ0JBQTJCO0FBQ3hDLEdBQXdCLENBQXhCLGNBQXdCO0FBQzNCLEdBQXFCLENBQXJCLFdBQXFCO0FBRWYsR0FBVyxDQUFYLFFBQVc7Ozs7OztBQUV4QyxFQUE4RCxBQUE5RCw0REFBOEQ7TUFDeERBLFNBQVMsU0FBU0MsVUFBUzs7O1FBQWpDLElBSUMsQ0FI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