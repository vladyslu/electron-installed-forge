"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = exports.listrPackage = void 0;
var _path = _interopRequireDefault(require("path"));
var _util = require("util");
var _coreUtils = require("@electron-forge/core-utils");
var _get = require("@electron/get");
var _chalk = _interopRequireDefault(require("chalk"));
var _debug = _interopRequireDefault(require("debug"));
var _electronPackager = _interopRequireDefault(require("electron-packager"));
var _fastGlob = _interopRequireDefault(require("fast-glob"));
var _fsExtra = _interopRequireDefault(require("fs-extra"));
var _listr2 = require("listr2");
var _forgeConfig = _interopRequireDefault(require("../util/forge-config"));
var _hook = require("../util/hook");
var _messages = require("../util/messages");
var _outDir = _interopRequireDefault(require("../util/out-dir"));
var _readPackageJson = require("../util/read-package-json");
var _requireSearch = _interopRequireDefault(require("../util/require-search"));
var _resolveDir = _interopRequireDefault(require("../util/resolve-dir"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const d = (0, _debug).default('electron-forge:packager');
/**
 * Resolves hooks if they are a path to a file (instead of a `Function`).
 */ function resolveHooks(hooks, dir) {
    if (hooks) {
        return hooks.map((hook)=>typeof hook === 'string' ? (0, _requireSearch).default(dir, [
                hook
            ]) : hook
        );
    }
    return [];
}
/**
 * Runs given hooks sequentially by mapping them to promises and iterating
 * through while awaiting
 */ function sequentialHooks(hooks) {
    return [
        async (buildPath, electronVersion, platform, arch, done)=>{
            for (const hook of hooks){
                try {
                    await (0, _util).promisify(hook)(buildPath, electronVersion, platform, arch);
                } catch (err) {
                    d('hook failed:', hook.toString(), err);
                    return done(err);
                }
            }
            done();
        }, 
    ];
}
function sequentialFinalizePackageTargetsHooks(hooks) {
    return [
        async (targets, done)=>{
            for (const hook of hooks){
                try {
                    await (0, _util).promisify(hook)(targets);
                } catch (err) {
                    return done(err);
                }
            }
            done();
        }, 
    ];
}
const listrPackage = ({ dir: providedDir = process.cwd() , interactive =false , arch: arch1 = (0, _get).getHostArch() , platform: platform1 = process.platform , outDir  })=>{
    const runner = new _listr2.Listr([
        {
            title: 'Preparing to package application',
            task: async (ctx)=>{
                const resolvedDir = await (0, _resolveDir).default(providedDir);
                if (!resolvedDir) {
                    throw new Error('Failed to locate compilable Electron application');
                }
                ctx.dir = resolvedDir;
                ctx.forgeConfig = await (0, _forgeConfig).default(resolvedDir);
                ctx.packageJSON = await (0, _readPackageJson).readMutatedPackageJson(resolvedDir, ctx.forgeConfig);
                if (!ctx.packageJSON.main) {
                    throw new Error('packageJSON.main must be set to a valid entry point for your Electron app');
                }
                ctx.calculatedOutDir = outDir || (0, _outDir).default(resolvedDir, ctx.forgeConfig);
            }
        },
        {
            title: 'Running packaging hooks',
            task: async ({ forgeConfig  }, task1)=>{
                return task1.newListr([
                    {
                        title: `Running ${_chalk.default.yellow('generateAssets')} hook`,
                        task: async (_, task)=>{
                            return task.newListr(await (0, _hook).getHookListrTasks(forgeConfig, 'generateAssets', platform1, arch1));
                        }
                    },
                    {
                        title: `Running ${_chalk.default.yellow('prePackage')} hook`,
                        task: async (_, task)=>{
                            return task.newListr(await (0, _hook).getHookListrTasks(forgeConfig, 'prePackage', platform1, arch1));
                        }
                    }, 
                ]);
            }
        },
        {
            title: 'Packaging application',
            task: async (ctx, task2)=>{
                const { calculatedOutDir , forgeConfig , packageJSON  } = ctx;
                const getTargetKey = (target)=>`${target.platform}/${target.arch}`
                ;
                task2.output = 'Determining targets...';
                let provideTargets;
                const targetsPromise = new Promise((resolve)=>{
                    provideTargets = resolve;
                });
                const signalCopyDone = new Map();
                const signalRebuildDone = new Map();
                const signalPackageDone = new Map();
                const rejects = [];
                const signalDone = (map, target)=>{
                    var ref, ref1;
                    (ref1 = (ref = map.get(getTargetKey(target))) === null || ref === void 0 ? void 0 : ref.pop()) === null || ref1 === void 0 ? void 0 : ref1();
                };
                const addSignalAndWait = async (map, target)=>{
                    const targetKey = getTargetKey(target);
                    await new Promise((resolve, reject)=>{
                        rejects.push(reject);
                        map.set(targetKey, (map.get(targetKey) || []).concat([
                            resolve
                        ]));
                    });
                };
                const rebuildTasks = new Map();
                const signalRebuildStart = new Map();
                const afterFinalizePackageTargetsHooks = [
                    (targets, done)=>{
                        provideTargets(targets);
                        done();
                    },
                    ...resolveHooks(forgeConfig.packagerConfig.afterFinalizePackageTargets, ctx.dir), 
                ];
                const pruneEnabled = !('prune' in forgeConfig.packagerConfig) || forgeConfig.packagerConfig.prune;
                const afterCopyHooks = [
                    async (buildPath, electronVersion, platform, arch, done)=>{
                        signalDone(signalCopyDone, {
                            platform,
                            arch
                        });
                        done();
                    },
                    async (buildPath, electronVersion, pPlatform, pArch, done)=>{
                        const bins = await (0, _fastGlob).default(_path.default.join(buildPath, '**/.bin/**/*'));
                        for (const bin of bins){
                            await _fsExtra.default.remove(bin);
                        }
                        done();
                    },
                    async (buildPath, electronVersion, pPlatform, pArch, done)=>{
                        await (0, _hook).runHook(forgeConfig, 'packageAfterCopy', buildPath, electronVersion, pPlatform, pArch);
                        done();
                    },
                    async (buildPath, electronVersion, pPlatform, pArch, done)=>{
                        var ref, ref2;
                        const targetKey = getTargetKey({
                            platform: pPlatform,
                            arch: pArch
                        });
                        await (0, _coreUtils).listrCompatibleRebuildHook(buildPath, electronVersion, pPlatform, pArch, forgeConfig.rebuildConfig, // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        await rebuildTasks.get(targetKey).pop());
                        (ref2 = (ref = signalRebuildDone.get(targetKey)) === null || ref === void 0 ? void 0 : ref.pop()) === null || ref2 === void 0 ? void 0 : ref2();
                        done();
                    },
                    async (buildPath, electronVersion, pPlatform, pArch, done)=>{
                        const copiedPackageJSON = await (0, _readPackageJson).readMutatedPackageJson(buildPath, forgeConfig);
                        if (copiedPackageJSON.config && copiedPackageJSON.config.forge) {
                            delete copiedPackageJSON.config.forge;
                        }
                        await _fsExtra.default.writeJson(_path.default.resolve(buildPath, 'package.json'), copiedPackageJSON, {
                            spaces: 2
                        });
                        done();
                    },
                    ...resolveHooks(forgeConfig.packagerConfig.afterCopy, ctx.dir), 
                ];
                const afterCompleteHooks = [
                    async (buildPath, electronVersion, pPlatform, pArch, done)=>{
                        var ref, ref3;
                        (ref3 = (ref = signalPackageDone.get(getTargetKey({
                            platform: pPlatform,
                            arch: pArch
                        }))) === null || ref === void 0 ? void 0 : ref.pop()) === null || ref3 === void 0 ? void 0 : ref3();
                        done();
                    }, 
                ];
                const afterPruneHooks = [];
                if (pruneEnabled) {
                    afterPruneHooks.push(...resolveHooks(forgeConfig.packagerConfig.afterPrune, ctx.dir));
                }
                afterPruneHooks.push(async (buildPath, electronVersion, pPlatform, pArch, done)=>{
                    await (0, _hook).runHook(forgeConfig, 'packageAfterPrune', buildPath, electronVersion, pPlatform, pArch);
                    done();
                });
                const afterExtractHooks = [
                    async (buildPath, electronVersion, pPlatform, pArch, done)=>{
                        await (0, _hook).runHook(forgeConfig, 'packageAfterExtract', buildPath, electronVersion, pPlatform, pArch);
                        done();
                    }, 
                ];
                afterExtractHooks.push(...resolveHooks(forgeConfig.packagerConfig.afterExtract, ctx.dir));
                const packageOpts = {
                    asar: false,
                    overwrite: true,
                    ignore: [
                        /^\/out\//g
                    ],
                    ...forgeConfig.packagerConfig,
                    quiet: true,
                    dir: ctx.dir,
                    arch: arch1,
                    platform: platform1,
                    afterFinalizePackageTargets: sequentialFinalizePackageTargetsHooks(afterFinalizePackageTargetsHooks),
                    afterComplete: sequentialHooks(afterCompleteHooks),
                    afterCopy: sequentialHooks(afterCopyHooks),
                    afterExtract: sequentialHooks(afterExtractHooks),
                    afterPrune: sequentialHooks(afterPruneHooks),
                    out: calculatedOutDir,
                    electronVersion: await (0, _coreUtils).getElectronVersion(ctx.dir, packageJSON)
                };
                packageOpts.quiet = true;
                if (packageOpts.all) {
                    throw new Error('config.forge.packagerConfig.all is not supported by Electron Forge');
                }
                if (!packageJSON.version && !packageOpts.appVersion) {
                    (0, _messages).warn(interactive, _chalk.default.yellow('Please set "version" or "config.forge.packagerConfig.appVersion" in your application\'s package.json so auto-updates work properly'));
                }
                if (packageOpts.prebuiltAsar) {
                    throw new Error('config.forge.packagerConfig.prebuiltAsar is not supported by Electron Forge');
                }
                d('packaging with options', packageOpts);
                ctx.packagerPromise = (0, _electronPackager).default(packageOpts);
                // Handle error by failing this task
                // rejects is populated by the reject handlers for every
                // signal based promise in every subtask
                ctx.packagerPromise.catch((err)=>{
                    for (const reject of rejects)reject(err);
                });
                const targets1 = await targetsPromise;
                // Copy the resolved targets into the context for later
                ctx.targets = [
                    ...targets1
                ];
                // If we are targetting a universal build we need to add the "fake"
                // x64 and arm64 builds into the list of targets so that we can
                // show progress for those
                for (const target2 of targets1){
                    if (target2.arch === 'universal') {
                        targets1.push({
                            platform: target2.platform,
                            arch: 'x64',
                            forUniversal: true
                        }, {
                            platform: target2.platform,
                            arch: 'arm64',
                            forUniversal: true
                        });
                    }
                }
                // Populate rebuildTasks with promises that resolve with the rebuild tasks
                // that will eventually run
                for (const target1 of targets1){
                    // Skip universal tasks as they do not have rebuild sub-tasks
                    if (target1.arch === 'universal') continue;
                    const targetKey = getTargetKey(target1);
                    rebuildTasks.set(targetKey, (rebuildTasks.get(targetKey) || []).concat([
                        new Promise((resolve)=>{
                            signalRebuildStart.set(targetKey, (signalRebuildStart.get(targetKey) || []).concat([
                                resolve
                            ]));
                        }), 
                    ]));
                }
                d('targets:', targets1);
                return task2.newListr(targets1.map((target)=>{
                    return target.arch === 'universal' ? {
                        title: `Stitching ${_chalk.default.cyan(`${target.platform}/x64`)} and ${_chalk.default.cyan(`${target.platform}/arm64`)} into a ${_chalk.default.green(`${target.platform}/universal`)} package`,
                        task: async ()=>{
                            await addSignalAndWait(signalPackageDone, target);
                        },
                        options: {
                            showTimer: true
                        }
                    } : {
                        title: `Packaging for ${_chalk.default.cyan(target.arch)} on ${_chalk.default.cyan(target.platform)}${target.forUniversal ? _chalk.default.italic(' (for universal package)') : ''}`,
                        task: async (_, task3)=>{
                            return task3.newListr([
                                {
                                    title: 'Copying files',
                                    task: async ()=>{
                                        await addSignalAndWait(signalCopyDone, target);
                                    }
                                },
                                {
                                    title: 'Preparing native dependencies',
                                    task: async (_, task)=>{
                                        var ref, ref4;
                                        (ref4 = (ref = signalRebuildStart.get(getTargetKey(target))) === null || ref === void 0 ? void 0 : ref.pop()) === null || ref4 === void 0 ? void 0 : ref4(task);
                                        await addSignalAndWait(signalRebuildDone, target);
                                    },
                                    options: {
                                        persistentOutput: true,
                                        bottomBar: Infinity,
                                        showTimer: true
                                    }
                                },
                                {
                                    title: 'Finalizing package',
                                    task: async ()=>{
                                        await addSignalAndWait(signalPackageDone, target);
                                    }
                                }, 
                            ], {
                                rendererOptions: {
                                    collapse: true,
                                    collapseErrors: false
                                }
                            });
                        },
                        options: {
                            showTimer: true
                        }
                    };
                }), {
                    concurrent: true,
                    rendererOptions: {
                        collapse: false,
                        collapseErrors: false
                    }
                });
            }
        },
        {
            title: `Running ${_chalk.default.yellow('postPackage')} hook`,
            task: async ({ packagerPromise , forgeConfig  }, task)=>{
                const outputPaths = await packagerPromise;
                d('outputPaths:', outputPaths);
                return task.newListr(await (0, _hook).getHookListrTasks(forgeConfig, 'postPackage', {
                    arch: arch1,
                    outputPaths,
                    platform: platform1
                }));
            }
        }, 
    ], {
        concurrent: false,
        rendererSilent: !interactive,
        rendererFallback: Boolean(process.env.DEBUG && process.env.DEBUG.includes('electron-forge')),
        rendererOptions: {
            collapse: false,
            collapseErrors: false
        },
        ctx: {}
    });
    return runner;
};
exports.listrPackage = listrPackage;
var _default = async (opts)=>{
    const runner = listrPackage(opts);
    await runner.run();
    const outputPaths = await runner.ctx.packagerPromise;
    return runner.ctx.targets.map((target, index)=>({
            platform: target.platform,
            arch: target.arch,
            packagedPath: outputPaths[index]
        })
    );
};
exports.default = _default;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hcGkvcGFja2FnZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IHByb21pc2lmeSB9IGZyb20gJ3V0aWwnO1xuXG5pbXBvcnQgeyBnZXRFbGVjdHJvblZlcnNpb24sIGxpc3RyQ29tcGF0aWJsZVJlYnVpbGRIb29rIH0gZnJvbSAnQGVsZWN0cm9uLWZvcmdlL2NvcmUtdXRpbHMnO1xuaW1wb3J0IHsgRm9yZ2VBcmNoLCBGb3JnZUxpc3RyVGFzaywgRm9yZ2VMaXN0clRhc2tEZWZpbml0aW9uLCBGb3JnZVBsYXRmb3JtLCBSZXNvbHZlZEZvcmdlQ29uZmlnIH0gZnJvbSAnQGVsZWN0cm9uLWZvcmdlL3NoYXJlZC10eXBlcyc7XG5pbXBvcnQgeyBnZXRIb3N0QXJjaCB9IGZyb20gJ0BlbGVjdHJvbi9nZXQnO1xuaW1wb3J0IGNoYWxrIGZyb20gJ2NoYWxrJztcbmltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQgcGFja2FnZXIsIHsgRmluYWxpemVQYWNrYWdlVGFyZ2V0c0hvb2tGdW5jdGlvbiwgSG9va0Z1bmN0aW9uLCBUYXJnZXREZWZpbml0aW9uIH0gZnJvbSAnZWxlY3Ryb24tcGFja2FnZXInO1xuaW1wb3J0IGdsb2IgZnJvbSAnZmFzdC1nbG9iJztcbmltcG9ydCBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgeyBMaXN0ciB9IGZyb20gJ2xpc3RyMic7XG5cbmltcG9ydCBnZXRGb3JnZUNvbmZpZyBmcm9tICcuLi91dGlsL2ZvcmdlLWNvbmZpZyc7XG5pbXBvcnQgeyBnZXRIb29rTGlzdHJUYXNrcywgcnVuSG9vayB9IGZyb20gJy4uL3V0aWwvaG9vayc7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vdXRpbC9tZXNzYWdlcyc7XG5pbXBvcnQgZ2V0Q3VycmVudE91dERpciBmcm9tICcuLi91dGlsL291dC1kaXInO1xuaW1wb3J0IHsgcmVhZE11dGF0ZWRQYWNrYWdlSnNvbiB9IGZyb20gJy4uL3V0aWwvcmVhZC1wYWNrYWdlLWpzb24nO1xuaW1wb3J0IHJlcXVpcmVTZWFyY2ggZnJvbSAnLi4vdXRpbC9yZXF1aXJlLXNlYXJjaCc7XG5pbXBvcnQgcmVzb2x2ZURpciBmcm9tICcuLi91dGlsL3Jlc29sdmUtZGlyJztcblxuY29uc3QgZCA9IGRlYnVnKCdlbGVjdHJvbi1mb3JnZTpwYWNrYWdlcicpO1xuXG4vKipcbiAqIFJlc29sdmVzIGhvb2tzIGlmIHRoZXkgYXJlIGEgcGF0aCB0byBhIGZpbGUgKGluc3RlYWQgb2YgYSBgRnVuY3Rpb25gKS5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUhvb2tzPEYgPSBIb29rRnVuY3Rpb24+KGhvb2tzOiAoc3RyaW5nIHwgRilbXSB8IHVuZGVmaW5lZCwgZGlyOiBzdHJpbmcpIHtcbiAgaWYgKGhvb2tzKSB7XG4gICAgcmV0dXJuIGhvb2tzLm1hcCgoaG9vaykgPT4gKHR5cGVvZiBob29rID09PSAnc3RyaW5nJyA/IChyZXF1aXJlU2VhcmNoPEY+KGRpciwgW2hvb2tdKSBhcyBGKSA6IGhvb2spKTtcbiAgfVxuXG4gIHJldHVybiBbXTtcbn1cblxudHlwZSBEb25lRnVuY3Rpb24gPSAoZXJyPzogRXJyb3IpID0+IHZvaWQ7XG50eXBlIFByb21pc2lmaWVkSG9va0Z1bmN0aW9uID0gKGJ1aWxkUGF0aDogc3RyaW5nLCBlbGVjdHJvblZlcnNpb246IHN0cmluZywgcGxhdGZvcm06IHN0cmluZywgYXJjaDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xudHlwZSBQcm9taXNpZmllZEZpbmFsaXplUGFja2FnZVRhcmdldHNIb29rRnVuY3Rpb24gPSAodGFyZ2V0czogVGFyZ2V0RGVmaW5pdGlvbltdKSA9PiBQcm9taXNlPHZvaWQ+O1xuXG4vKipcbiAqIFJ1bnMgZ2l2ZW4gaG9va3Mgc2VxdWVudGlhbGx5IGJ5IG1hcHBpbmcgdGhlbSB0byBwcm9taXNlcyBhbmQgaXRlcmF0aW5nXG4gKiB0aHJvdWdoIHdoaWxlIGF3YWl0aW5nXG4gKi9cbmZ1bmN0aW9uIHNlcXVlbnRpYWxIb29rcyhob29rczogSG9va0Z1bmN0aW9uW10pOiBQcm9taXNpZmllZEhvb2tGdW5jdGlvbltdIHtcbiAgcmV0dXJuIFtcbiAgICBhc3luYyAoYnVpbGRQYXRoOiBzdHJpbmcsIGVsZWN0cm9uVmVyc2lvbjogc3RyaW5nLCBwbGF0Zm9ybTogc3RyaW5nLCBhcmNoOiBzdHJpbmcsIGRvbmU6IERvbmVGdW5jdGlvbikgPT4ge1xuICAgICAgZm9yIChjb25zdCBob29rIG9mIGhvb2tzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgcHJvbWlzaWZ5KGhvb2spKGJ1aWxkUGF0aCwgZWxlY3Ryb25WZXJzaW9uLCBwbGF0Zm9ybSwgYXJjaCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGQoJ2hvb2sgZmFpbGVkOicsIGhvb2sudG9TdHJpbmcoKSwgZXJyKTtcbiAgICAgICAgICByZXR1cm4gZG9uZShlcnIgYXMgRXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkb25lKCk7XG4gICAgfSxcbiAgXSBhcyBQcm9taXNpZmllZEhvb2tGdW5jdGlvbltdO1xufVxuZnVuY3Rpb24gc2VxdWVudGlhbEZpbmFsaXplUGFja2FnZVRhcmdldHNIb29rcyhob29rczogRmluYWxpemVQYWNrYWdlVGFyZ2V0c0hvb2tGdW5jdGlvbltdKTogUHJvbWlzaWZpZWRGaW5hbGl6ZVBhY2thZ2VUYXJnZXRzSG9va0Z1bmN0aW9uW10ge1xuICByZXR1cm4gW1xuICAgIGFzeW5jICh0YXJnZXRzOiBUYXJnZXREZWZpbml0aW9uW10sIGRvbmU6IERvbmVGdW5jdGlvbikgPT4ge1xuICAgICAgZm9yIChjb25zdCBob29rIG9mIGhvb2tzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgcHJvbWlzaWZ5KGhvb2spKHRhcmdldHMpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gZG9uZShlcnIgYXMgRXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkb25lKCk7XG4gICAgfSxcbiAgXSBhcyBQcm9taXNpZmllZEZpbmFsaXplUGFja2FnZVRhcmdldHNIb29rRnVuY3Rpb25bXTtcbn1cblxudHlwZSBQYWNrYWdlQ29udGV4dCA9IHtcbiAgZGlyOiBzdHJpbmc7XG4gIGZvcmdlQ29uZmlnOiBSZXNvbHZlZEZvcmdlQ29uZmlnO1xuICBwYWNrYWdlSlNPTjogYW55O1xuICBjYWxjdWxhdGVkT3V0RGlyOiBzdHJpbmc7XG4gIHBhY2thZ2VyUHJvbWlzZTogUHJvbWlzZTxzdHJpbmdbXT47XG4gIHRhcmdldHM6IEludGVybmFsVGFyZ2V0RGVmaW5pdGlvbltdO1xufTtcblxudHlwZSBJbnRlcm5hbFRhcmdldERlZmluaXRpb24gPSBUYXJnZXREZWZpbml0aW9uICYge1xuICBmb3JVbml2ZXJzYWw/OiBib29sZWFuO1xufTtcblxudHlwZSBQYWNrYWdlUmVzdWx0ID0gVGFyZ2V0RGVmaW5pdGlvbiAmIHtcbiAgcGFja2FnZWRQYXRoOiBzdHJpbmc7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIFBhY2thZ2VPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBwYXRoIHRvIHRoZSBhcHAgdG8gcGFja2FnZVxuICAgKi9cbiAgZGlyPzogc3RyaW5nO1xuICAvKipcbiAgICogV2hldGhlciB0byB1c2Ugc2Vuc2libGUgZGVmYXVsdHMgb3IgcHJvbXB0IHRoZSB1c2VyIHZpc3VhbGx5XG4gICAqL1xuICBpbnRlcmFjdGl2ZT86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBUaGUgdGFyZ2V0IGFyY2hcbiAgICovXG4gIGFyY2g/OiBGb3JnZUFyY2g7XG4gIC8qKlxuICAgKiBUaGUgdGFyZ2V0IHBsYXRmb3JtLlxuICAgKi9cbiAgcGxhdGZvcm0/OiBGb3JnZVBsYXRmb3JtO1xuICAvKipcbiAgICogVGhlIHBhdGggdG8gdGhlIG91dHB1dCBkaXJlY3RvcnkgZm9yIHBhY2thZ2VkIGFwcHNcbiAgICovXG4gIG91dERpcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IGxpc3RyUGFja2FnZSA9ICh7XG4gIGRpcjogcHJvdmlkZWREaXIgPSBwcm9jZXNzLmN3ZCgpLFxuICBpbnRlcmFjdGl2ZSA9IGZhbHNlLFxuICBhcmNoID0gZ2V0SG9zdEFyY2goKSBhcyBGb3JnZUFyY2gsXG4gIHBsYXRmb3JtID0gcHJvY2Vzcy5wbGF0Zm9ybSBhcyBGb3JnZVBsYXRmb3JtLFxuICBvdXREaXIsXG59OiBQYWNrYWdlT3B0aW9ucykgPT4ge1xuICBjb25zdCBydW5uZXIgPSBuZXcgTGlzdHI8UGFja2FnZUNvbnRleHQ+KFxuICAgIFtcbiAgICAgIHtcbiAgICAgICAgdGl0bGU6ICdQcmVwYXJpbmcgdG8gcGFja2FnZSBhcHBsaWNhdGlvbicsXG4gICAgICAgIHRhc2s6IGFzeW5jIChjdHgpID0+IHtcbiAgICAgICAgICBjb25zdCByZXNvbHZlZERpciA9IGF3YWl0IHJlc29sdmVEaXIocHJvdmlkZWREaXIpO1xuICAgICAgICAgIGlmICghcmVzb2x2ZWREaXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGxvY2F0ZSBjb21waWxhYmxlIEVsZWN0cm9uIGFwcGxpY2F0aW9uJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5kaXIgPSByZXNvbHZlZERpcjtcblxuICAgICAgICAgIGN0eC5mb3JnZUNvbmZpZyA9IGF3YWl0IGdldEZvcmdlQ29uZmlnKHJlc29sdmVkRGlyKTtcbiAgICAgICAgICBjdHgucGFja2FnZUpTT04gPSBhd2FpdCByZWFkTXV0YXRlZFBhY2thZ2VKc29uKHJlc29sdmVkRGlyLCBjdHguZm9yZ2VDb25maWcpO1xuXG4gICAgICAgICAgaWYgKCFjdHgucGFja2FnZUpTT04ubWFpbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWNrYWdlSlNPTi5tYWluIG11c3QgYmUgc2V0IHRvIGEgdmFsaWQgZW50cnkgcG9pbnQgZm9yIHlvdXIgRWxlY3Ryb24gYXBwJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3R4LmNhbGN1bGF0ZWRPdXREaXIgPSBvdXREaXIgfHwgZ2V0Q3VycmVudE91dERpcihyZXNvbHZlZERpciwgY3R4LmZvcmdlQ29uZmlnKTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRpdGxlOiAnUnVubmluZyBwYWNrYWdpbmcgaG9va3MnLFxuICAgICAgICB0YXNrOiBhc3luYyAoeyBmb3JnZUNvbmZpZyB9LCB0YXNrKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRhc2submV3TGlzdHIoW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aXRsZTogYFJ1bm5pbmcgJHtjaGFsay55ZWxsb3coJ2dlbmVyYXRlQXNzZXRzJyl9IGhvb2tgLFxuICAgICAgICAgICAgICB0YXNrOiBhc3luYyAoXywgdGFzaykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXNrLm5ld0xpc3RyKGF3YWl0IGdldEhvb2tMaXN0clRhc2tzKGZvcmdlQ29uZmlnLCAnZ2VuZXJhdGVBc3NldHMnLCBwbGF0Zm9ybSwgYXJjaCkpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGl0bGU6IGBSdW5uaW5nICR7Y2hhbGsueWVsbG93KCdwcmVQYWNrYWdlJyl9IGhvb2tgLFxuICAgICAgICAgICAgICB0YXNrOiBhc3luYyAoXywgdGFzaykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXNrLm5ld0xpc3RyKGF3YWl0IGdldEhvb2tMaXN0clRhc2tzKGZvcmdlQ29uZmlnLCAncHJlUGFja2FnZScsIHBsYXRmb3JtLCBhcmNoKSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF0pO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdGl0bGU6ICdQYWNrYWdpbmcgYXBwbGljYXRpb24nLFxuICAgICAgICB0YXNrOiBhc3luYyAoY3R4LCB0YXNrKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBjYWxjdWxhdGVkT3V0RGlyLCBmb3JnZUNvbmZpZywgcGFja2FnZUpTT04gfSA9IGN0eDtcbiAgICAgICAgICBjb25zdCBnZXRUYXJnZXRLZXkgPSAodGFyZ2V0OiBUYXJnZXREZWZpbml0aW9uKSA9PiBgJHt0YXJnZXQucGxhdGZvcm19LyR7dGFyZ2V0LmFyY2h9YDtcblxuICAgICAgICAgIHRhc2sub3V0cHV0ID0gJ0RldGVybWluaW5nIHRhcmdldHMuLi4nO1xuXG4gICAgICAgICAgbGV0IHByb3ZpZGVUYXJnZXRzOiAodGFyZ2V0czogVGFyZ2V0RGVmaW5pdGlvbltdKSA9PiB2b2lkO1xuICAgICAgICAgIGNvbnN0IHRhcmdldHNQcm9taXNlID0gbmV3IFByb21pc2U8SW50ZXJuYWxUYXJnZXREZWZpbml0aW9uW10+KChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBwcm92aWRlVGFyZ2V0cyA9IHJlc29sdmU7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0eXBlIFN0ZXBEb25lU2lnbmFsTWFwID0gTWFwPHN0cmluZywgKCgpID0+IHZvaWQpW10+O1xuICAgICAgICAgIGNvbnN0IHNpZ25hbENvcHlEb25lOiBTdGVwRG9uZVNpZ25hbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICBjb25zdCBzaWduYWxSZWJ1aWxkRG9uZTogU3RlcERvbmVTaWduYWxNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgY29uc3Qgc2lnbmFsUGFja2FnZURvbmU6IFN0ZXBEb25lU2lnbmFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgIGNvbnN0IHJlamVjdHM6ICgoZXJyOiBhbnkpID0+IHZvaWQpW10gPSBbXTtcbiAgICAgICAgICBjb25zdCBzaWduYWxEb25lID0gKG1hcDogU3RlcERvbmVTaWduYWxNYXAsIHRhcmdldDogVGFyZ2V0RGVmaW5pdGlvbikgPT4ge1xuICAgICAgICAgICAgbWFwLmdldChnZXRUYXJnZXRLZXkodGFyZ2V0KSk/LnBvcCgpPy4oKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IGFkZFNpZ25hbEFuZFdhaXQgPSBhc3luYyAobWFwOiBTdGVwRG9uZVNpZ25hbE1hcCwgdGFyZ2V0OiBUYXJnZXREZWZpbml0aW9uKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRLZXkgPSBnZXRUYXJnZXRLZXkodGFyZ2V0KTtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgcmVqZWN0cy5wdXNoKHJlamVjdCk7XG4gICAgICAgICAgICAgIG1hcC5zZXQodGFyZ2V0S2V5LCAobWFwLmdldCh0YXJnZXRLZXkpIHx8IFtdKS5jb25jYXQoW3Jlc29sdmVdKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc3QgcmVidWlsZFRhc2tzID0gbmV3IE1hcDxzdHJpbmcsIFByb21pc2U8Rm9yZ2VMaXN0clRhc2s8bmV2ZXI+PltdPigpO1xuICAgICAgICAgIGNvbnN0IHNpZ25hbFJlYnVpbGRTdGFydCA9IG5ldyBNYXA8c3RyaW5nLCAoKHRhc2s6IEZvcmdlTGlzdHJUYXNrPG5ldmVyPikgPT4gdm9pZClbXT4oKTtcblxuICAgICAgICAgIGNvbnN0IGFmdGVyRmluYWxpemVQYWNrYWdlVGFyZ2V0c0hvb2tzOiBGaW5hbGl6ZVBhY2thZ2VUYXJnZXRzSG9va0Z1bmN0aW9uW10gPSBbXG4gICAgICAgICAgICAodGFyZ2V0cywgZG9uZSkgPT4ge1xuICAgICAgICAgICAgICBwcm92aWRlVGFyZ2V0cyh0YXJnZXRzKTtcbiAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC4uLnJlc29sdmVIb29rcyhmb3JnZUNvbmZpZy5wYWNrYWdlckNvbmZpZy5hZnRlckZpbmFsaXplUGFja2FnZVRhcmdldHMsIGN0eC5kaXIpLFxuICAgICAgICAgIF07XG5cbiAgICAgICAgICBjb25zdCBwcnVuZUVuYWJsZWQgPSAhKCdwcnVuZScgaW4gZm9yZ2VDb25maWcucGFja2FnZXJDb25maWcpIHx8IGZvcmdlQ29uZmlnLnBhY2thZ2VyQ29uZmlnLnBydW5lO1xuXG4gICAgICAgICAgY29uc3QgYWZ0ZXJDb3B5SG9va3M6IEhvb2tGdW5jdGlvbltdID0gW1xuICAgICAgICAgICAgYXN5bmMgKGJ1aWxkUGF0aCwgZWxlY3Ryb25WZXJzaW9uLCBwbGF0Zm9ybSwgYXJjaCwgZG9uZSkgPT4ge1xuICAgICAgICAgICAgICBzaWduYWxEb25lKHNpZ25hbENvcHlEb25lLCB7IHBsYXRmb3JtLCBhcmNoIH0pO1xuICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXN5bmMgKGJ1aWxkUGF0aCwgZWxlY3Ryb25WZXJzaW9uLCBwUGxhdGZvcm0sIHBBcmNoLCBkb25lKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGJpbnMgPSBhd2FpdCBnbG9iKHBhdGguam9pbihidWlsZFBhdGgsICcqKi8uYmluLyoqLyonKSk7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgYmluIG9mIGJpbnMpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBmcy5yZW1vdmUoYmluKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXN5bmMgKGJ1aWxkUGF0aCwgZWxlY3Ryb25WZXJzaW9uLCBwUGxhdGZvcm0sIHBBcmNoLCBkb25lKSA9PiB7XG4gICAgICAgICAgICAgIGF3YWl0IHJ1bkhvb2soZm9yZ2VDb25maWcsICdwYWNrYWdlQWZ0ZXJDb3B5JywgYnVpbGRQYXRoLCBlbGVjdHJvblZlcnNpb24sIHBQbGF0Zm9ybSwgcEFyY2gpO1xuICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXN5bmMgKGJ1aWxkUGF0aCwgZWxlY3Ryb25WZXJzaW9uLCBwUGxhdGZvcm0sIHBBcmNoLCBkb25lKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHRhcmdldEtleSA9IGdldFRhcmdldEtleSh7IHBsYXRmb3JtOiBwUGxhdGZvcm0sIGFyY2g6IHBBcmNoIH0pO1xuICAgICAgICAgICAgICBhd2FpdCBsaXN0ckNvbXBhdGlibGVSZWJ1aWxkSG9vayhcbiAgICAgICAgICAgICAgICBidWlsZFBhdGgsXG4gICAgICAgICAgICAgICAgZWxlY3Ryb25WZXJzaW9uLFxuICAgICAgICAgICAgICAgIHBQbGF0Zm9ybSxcbiAgICAgICAgICAgICAgICBwQXJjaCxcbiAgICAgICAgICAgICAgICBmb3JnZUNvbmZpZy5yZWJ1aWxkQ29uZmlnLFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgYXdhaXQgcmVidWlsZFRhc2tzLmdldCh0YXJnZXRLZXkpIS5wb3AoKSFcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgc2lnbmFsUmVidWlsZERvbmUuZ2V0KHRhcmdldEtleSk/LnBvcCgpPy4oKTtcbiAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFzeW5jIChidWlsZFBhdGgsIGVsZWN0cm9uVmVyc2lvbiwgcFBsYXRmb3JtLCBwQXJjaCwgZG9uZSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBjb3BpZWRQYWNrYWdlSlNPTiA9IGF3YWl0IHJlYWRNdXRhdGVkUGFja2FnZUpzb24oYnVpbGRQYXRoLCBmb3JnZUNvbmZpZyk7XG4gICAgICAgICAgICAgIGlmIChjb3BpZWRQYWNrYWdlSlNPTi5jb25maWcgJiYgY29waWVkUGFja2FnZUpTT04uY29uZmlnLmZvcmdlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNvcGllZFBhY2thZ2VKU09OLmNvbmZpZy5mb3JnZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhd2FpdCBmcy53cml0ZUpzb24ocGF0aC5yZXNvbHZlKGJ1aWxkUGF0aCwgJ3BhY2thZ2UuanNvbicpLCBjb3BpZWRQYWNrYWdlSlNPTiwgeyBzcGFjZXM6IDIgfSk7XG4gICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAuLi5yZXNvbHZlSG9va3MoZm9yZ2VDb25maWcucGFja2FnZXJDb25maWcuYWZ0ZXJDb3B5LCBjdHguZGlyKSxcbiAgICAgICAgICBdO1xuXG4gICAgICAgICAgY29uc3QgYWZ0ZXJDb21wbGV0ZUhvb2tzOiBIb29rRnVuY3Rpb25bXSA9IFtcbiAgICAgICAgICAgIGFzeW5jIChidWlsZFBhdGgsIGVsZWN0cm9uVmVyc2lvbiwgcFBsYXRmb3JtLCBwQXJjaCwgZG9uZSkgPT4ge1xuICAgICAgICAgICAgICBzaWduYWxQYWNrYWdlRG9uZS5nZXQoZ2V0VGFyZ2V0S2V5KHsgcGxhdGZvcm06IHBQbGF0Zm9ybSwgYXJjaDogcEFyY2ggfSkpPy5wb3AoKT8uKCk7XG4gICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXTtcblxuICAgICAgICAgIGNvbnN0IGFmdGVyUHJ1bmVIb29rcyA9IFtdO1xuXG4gICAgICAgICAgaWYgKHBydW5lRW5hYmxlZCkge1xuICAgICAgICAgICAgYWZ0ZXJQcnVuZUhvb2tzLnB1c2goLi4ucmVzb2x2ZUhvb2tzKGZvcmdlQ29uZmlnLnBhY2thZ2VyQ29uZmlnLmFmdGVyUHJ1bmUsIGN0eC5kaXIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhZnRlclBydW5lSG9va3MucHVzaCgoYXN5bmMgKGJ1aWxkUGF0aCwgZWxlY3Ryb25WZXJzaW9uLCBwUGxhdGZvcm0sIHBBcmNoLCBkb25lKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCBydW5Ib29rKGZvcmdlQ29uZmlnLCAncGFja2FnZUFmdGVyUHJ1bmUnLCBidWlsZFBhdGgsIGVsZWN0cm9uVmVyc2lvbiwgcFBsYXRmb3JtLCBwQXJjaCk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfSkgYXMgSG9va0Z1bmN0aW9uKTtcblxuICAgICAgICAgIGNvbnN0IGFmdGVyRXh0cmFjdEhvb2tzID0gW1xuICAgICAgICAgICAgKGFzeW5jIChidWlsZFBhdGgsIGVsZWN0cm9uVmVyc2lvbiwgcFBsYXRmb3JtLCBwQXJjaCwgZG9uZSkgPT4ge1xuICAgICAgICAgICAgICBhd2FpdCBydW5Ib29rKGZvcmdlQ29uZmlnLCAncGFja2FnZUFmdGVyRXh0cmFjdCcsIGJ1aWxkUGF0aCwgZWxlY3Ryb25WZXJzaW9uLCBwUGxhdGZvcm0sIHBBcmNoKTtcbiAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgfSkgYXMgSG9va0Z1bmN0aW9uLFxuICAgICAgICAgIF07XG4gICAgICAgICAgYWZ0ZXJFeHRyYWN0SG9va3MucHVzaCguLi5yZXNvbHZlSG9va3MoZm9yZ2VDb25maWcucGFja2FnZXJDb25maWcuYWZ0ZXJFeHRyYWN0LCBjdHguZGlyKSk7XG5cbiAgICAgICAgICB0eXBlIFBhY2thZ2VyQXJjaCA9IEV4Y2x1ZGU8Rm9yZ2VBcmNoLCAnYXJtJz47XG5cbiAgICAgICAgICBjb25zdCBwYWNrYWdlT3B0czogcGFja2FnZXIuT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGFzYXI6IGZhbHNlLFxuICAgICAgICAgICAgb3ZlcndyaXRlOiB0cnVlLFxuICAgICAgICAgICAgaWdub3JlOiBbL15cXC9vdXRcXC8vZ10sXG4gICAgICAgICAgICAuLi5mb3JnZUNvbmZpZy5wYWNrYWdlckNvbmZpZyxcbiAgICAgICAgICAgIHF1aWV0OiB0cnVlLFxuICAgICAgICAgICAgZGlyOiBjdHguZGlyLFxuICAgICAgICAgICAgYXJjaDogYXJjaCBhcyBQYWNrYWdlckFyY2gsXG4gICAgICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgICAgIGFmdGVyRmluYWxpemVQYWNrYWdlVGFyZ2V0czogc2VxdWVudGlhbEZpbmFsaXplUGFja2FnZVRhcmdldHNIb29rcyhhZnRlckZpbmFsaXplUGFja2FnZVRhcmdldHNIb29rcyksXG4gICAgICAgICAgICBhZnRlckNvbXBsZXRlOiBzZXF1ZW50aWFsSG9va3MoYWZ0ZXJDb21wbGV0ZUhvb2tzKSxcbiAgICAgICAgICAgIGFmdGVyQ29weTogc2VxdWVudGlhbEhvb2tzKGFmdGVyQ29weUhvb2tzKSxcbiAgICAgICAgICAgIGFmdGVyRXh0cmFjdDogc2VxdWVudGlhbEhvb2tzKGFmdGVyRXh0cmFjdEhvb2tzKSxcbiAgICAgICAgICAgIGFmdGVyUHJ1bmU6IHNlcXVlbnRpYWxIb29rcyhhZnRlclBydW5lSG9va3MpLFxuICAgICAgICAgICAgb3V0OiBjYWxjdWxhdGVkT3V0RGlyLFxuICAgICAgICAgICAgZWxlY3Ryb25WZXJzaW9uOiBhd2FpdCBnZXRFbGVjdHJvblZlcnNpb24oY3R4LmRpciwgcGFja2FnZUpTT04pLFxuICAgICAgICAgIH07XG4gICAgICAgICAgcGFja2FnZU9wdHMucXVpZXQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKHBhY2thZ2VPcHRzLmFsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb25maWcuZm9yZ2UucGFja2FnZXJDb25maWcuYWxsIGlzIG5vdCBzdXBwb3J0ZWQgYnkgRWxlY3Ryb24gRm9yZ2UnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXBhY2thZ2VKU09OLnZlcnNpb24gJiYgIXBhY2thZ2VPcHRzLmFwcFZlcnNpb24pIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIGludGVyYWN0aXZlLFxuICAgICAgICAgICAgICBjaGFsay55ZWxsb3coJ1BsZWFzZSBzZXQgXCJ2ZXJzaW9uXCIgb3IgXCJjb25maWcuZm9yZ2UucGFja2FnZXJDb25maWcuYXBwVmVyc2lvblwiIGluIHlvdXIgYXBwbGljYXRpb25cXCdzIHBhY2thZ2UuanNvbiBzbyBhdXRvLXVwZGF0ZXMgd29yayBwcm9wZXJseScpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwYWNrYWdlT3B0cy5wcmVidWlsdEFzYXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29uZmlnLmZvcmdlLnBhY2thZ2VyQ29uZmlnLnByZWJ1aWx0QXNhciBpcyBub3Qgc3VwcG9ydGVkIGJ5IEVsZWN0cm9uIEZvcmdlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZCgncGFja2FnaW5nIHdpdGggb3B0aW9ucycsIHBhY2thZ2VPcHRzKTtcblxuICAgICAgICAgIGN0eC5wYWNrYWdlclByb21pc2UgPSBwYWNrYWdlcihwYWNrYWdlT3B0cyk7XG4gICAgICAgICAgLy8gSGFuZGxlIGVycm9yIGJ5IGZhaWxpbmcgdGhpcyB0YXNrXG4gICAgICAgICAgLy8gcmVqZWN0cyBpcyBwb3B1bGF0ZWQgYnkgdGhlIHJlamVjdCBoYW5kbGVycyBmb3IgZXZlcnlcbiAgICAgICAgICAvLyBzaWduYWwgYmFzZWQgcHJvbWlzZSBpbiBldmVyeSBzdWJ0YXNrXG4gICAgICAgICAgY3R4LnBhY2thZ2VyUHJvbWlzZS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlamVjdCBvZiByZWplY3RzKSByZWplY3QoZXJyKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNvbnN0IHRhcmdldHMgPSBhd2FpdCB0YXJnZXRzUHJvbWlzZTtcbiAgICAgICAgICAvLyBDb3B5IHRoZSByZXNvbHZlZCB0YXJnZXRzIGludG8gdGhlIGNvbnRleHQgZm9yIGxhdGVyXG4gICAgICAgICAgY3R4LnRhcmdldHMgPSBbLi4udGFyZ2V0c107XG4gICAgICAgICAgLy8gSWYgd2UgYXJlIHRhcmdldHRpbmcgYSB1bml2ZXJzYWwgYnVpbGQgd2UgbmVlZCB0byBhZGQgdGhlIFwiZmFrZVwiXG4gICAgICAgICAgLy8geDY0IGFuZCBhcm02NCBidWlsZHMgaW50byB0aGUgbGlzdCBvZiB0YXJnZXRzIHNvIHRoYXQgd2UgY2FuXG4gICAgICAgICAgLy8gc2hvdyBwcm9ncmVzcyBmb3IgdGhvc2VcbiAgICAgICAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiB0YXJnZXRzKSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0LmFyY2ggPT09ICd1bml2ZXJzYWwnKSB7XG4gICAgICAgICAgICAgIHRhcmdldHMucHVzaChcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBwbGF0Zm9ybTogdGFyZ2V0LnBsYXRmb3JtLFxuICAgICAgICAgICAgICAgICAgYXJjaDogJ3g2NCcsXG4gICAgICAgICAgICAgICAgICBmb3JVbml2ZXJzYWw6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBwbGF0Zm9ybTogdGFyZ2V0LnBsYXRmb3JtLFxuICAgICAgICAgICAgICAgICAgYXJjaDogJ2FybTY0JyxcbiAgICAgICAgICAgICAgICAgIGZvclVuaXZlcnNhbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUG9wdWxhdGUgcmVidWlsZFRhc2tzIHdpdGggcHJvbWlzZXMgdGhhdCByZXNvbHZlIHdpdGggdGhlIHJlYnVpbGQgdGFza3NcbiAgICAgICAgICAvLyB0aGF0IHdpbGwgZXZlbnR1YWxseSBydW5cbiAgICAgICAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiB0YXJnZXRzKSB7XG4gICAgICAgICAgICAvLyBTa2lwIHVuaXZlcnNhbCB0YXNrcyBhcyB0aGV5IGRvIG5vdCBoYXZlIHJlYnVpbGQgc3ViLXRhc2tzXG4gICAgICAgICAgICBpZiAodGFyZ2V0LmFyY2ggPT09ICd1bml2ZXJzYWwnKSBjb250aW51ZTtcblxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0S2V5ID0gZ2V0VGFyZ2V0S2V5KHRhcmdldCk7XG4gICAgICAgICAgICByZWJ1aWxkVGFza3Muc2V0KFxuICAgICAgICAgICAgICB0YXJnZXRLZXksXG4gICAgICAgICAgICAgIChyZWJ1aWxkVGFza3MuZ2V0KHRhcmdldEtleSkgfHwgW10pLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICAgIHNpZ25hbFJlYnVpbGRTdGFydC5zZXQodGFyZ2V0S2V5LCAoc2lnbmFsUmVidWlsZFN0YXJ0LmdldCh0YXJnZXRLZXkpIHx8IFtdKS5jb25jYXQoW3Jlc29sdmVdKSk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkKCd0YXJnZXRzOicsIHRhcmdldHMpO1xuXG4gICAgICAgICAgcmV0dXJuIHRhc2submV3TGlzdHIoXG4gICAgICAgICAgICB0YXJnZXRzLm1hcChcbiAgICAgICAgICAgICAgKHRhcmdldCk6IEZvcmdlTGlzdHJUYXNrRGVmaW5pdGlvbiA9PlxuICAgICAgICAgICAgICAgIHRhcmdldC5hcmNoID09PSAndW5pdmVyc2FsJ1xuICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGBTdGl0Y2hpbmcgJHtjaGFsay5jeWFuKGAke3RhcmdldC5wbGF0Zm9ybX0veDY0YCl9IGFuZCAke2NoYWxrLmN5YW4oYCR7dGFyZ2V0LnBsYXRmb3JtfS9hcm02NGApfSBpbnRvIGEgJHtjaGFsay5ncmVlbihcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke3RhcmdldC5wbGF0Zm9ybX0vdW5pdmVyc2FsYFxuICAgICAgICAgICAgICAgICAgICAgICl9IHBhY2thZ2VgLFxuICAgICAgICAgICAgICAgICAgICAgIHRhc2s6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGFkZFNpZ25hbEFuZFdhaXQoc2lnbmFsUGFja2FnZURvbmUsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93VGltZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGBQYWNrYWdpbmcgZm9yICR7Y2hhbGsuY3lhbih0YXJnZXQuYXJjaCl9IG9uICR7Y2hhbGsuY3lhbih0YXJnZXQucGxhdGZvcm0pfSR7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuZm9yVW5pdmVyc2FsID8gY2hhbGsuaXRhbGljKCcgKGZvciB1bml2ZXJzYWwgcGFja2FnZSknKSA6ICcnXG4gICAgICAgICAgICAgICAgICAgICAgfWAsXG4gICAgICAgICAgICAgICAgICAgICAgdGFzazogYXN5bmMgKF8sIHRhc2spID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXNrLm5ld0xpc3RyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdDb3B5aW5nIGZpbGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2s6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgYWRkU2lnbmFsQW5kV2FpdChzaWduYWxDb3B5RG9uZSwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1ByZXBhcmluZyBuYXRpdmUgZGVwZW5kZW5jaWVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2s6IGFzeW5jIChfLCB0YXNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbFJlYnVpbGRTdGFydC5nZXQoZ2V0VGFyZ2V0S2V5KHRhcmdldCkpPy5wb3AoKT8uKHRhc2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBhZGRTaWduYWxBbmRXYWl0KHNpZ25hbFJlYnVpbGREb25lLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyc2lzdGVudE91dHB1dDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tQmFyOiBJbmZpbml0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvd1RpbWVyOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnRmluYWxpemluZyBwYWNrYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2s6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgYWRkU2lnbmFsQW5kV2FpdChzaWduYWxQYWNrYWdlRG9uZSwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgeyByZW5kZXJlck9wdGlvbnM6IHsgY29sbGFwc2U6IHRydWUsIGNvbGxhcHNlRXJyb3JzOiBmYWxzZSB9IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93VGltZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHsgY29uY3VycmVudDogdHJ1ZSwgcmVuZGVyZXJPcHRpb25zOiB7IGNvbGxhcHNlOiBmYWxzZSwgY29sbGFwc2VFcnJvcnM6IGZhbHNlIH0gfVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0aXRsZTogYFJ1bm5pbmcgJHtjaGFsay55ZWxsb3coJ3Bvc3RQYWNrYWdlJyl9IGhvb2tgLFxuICAgICAgICB0YXNrOiBhc3luYyAoeyBwYWNrYWdlclByb21pc2UsIGZvcmdlQ29uZmlnIH0sIHRhc2spID0+IHtcbiAgICAgICAgICBjb25zdCBvdXRwdXRQYXRocyA9IGF3YWl0IHBhY2thZ2VyUHJvbWlzZTtcbiAgICAgICAgICBkKCdvdXRwdXRQYXRoczonLCBvdXRwdXRQYXRocyk7XG4gICAgICAgICAgcmV0dXJuIHRhc2submV3TGlzdHIoXG4gICAgICAgICAgICBhd2FpdCBnZXRIb29rTGlzdHJUYXNrcyhmb3JnZUNvbmZpZywgJ3Bvc3RQYWNrYWdlJywge1xuICAgICAgICAgICAgICBhcmNoLFxuICAgICAgICAgICAgICBvdXRwdXRQYXRocyxcbiAgICAgICAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIF0sXG4gICAge1xuICAgICAgY29uY3VycmVudDogZmFsc2UsXG4gICAgICByZW5kZXJlclNpbGVudDogIWludGVyYWN0aXZlLFxuICAgICAgcmVuZGVyZXJGYWxsYmFjazogQm9vbGVhbihwcm9jZXNzLmVudi5ERUJVRyAmJiBwcm9jZXNzLmVudi5ERUJVRy5pbmNsdWRlcygnZWxlY3Ryb24tZm9yZ2UnKSksXG4gICAgICByZW5kZXJlck9wdGlvbnM6IHtcbiAgICAgICAgY29sbGFwc2U6IGZhbHNlLFxuICAgICAgICBjb2xsYXBzZUVycm9yczogZmFsc2UsXG4gICAgICB9LFxuICAgICAgY3R4OiB7fSBhcyBQYWNrYWdlQ29udGV4dCxcbiAgICB9XG4gICk7XG5cbiAgcmV0dXJuIHJ1bm5lcjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIChvcHRzOiBQYWNrYWdlT3B0aW9ucyk6IFByb21pc2U8UGFja2FnZVJlc3VsdFtdPiA9PiB7XG4gIGNvbnN0IHJ1bm5lciA9IGxpc3RyUGFja2FnZShvcHRzKTtcblxuICBhd2FpdCBydW5uZXIucnVuKCk7XG5cbiAgY29uc3Qgb3V0cHV0UGF0aHMgPSBhd2FpdCBydW5uZXIuY3R4LnBhY2thZ2VyUHJvbWlzZTtcbiAgcmV0dXJuIHJ1bm5lci5jdHgudGFyZ2V0cy5tYXAoKHRhcmdldCwgaW5kZXgpID0+ICh7XG4gICAgcGxhdGZvcm06IHRhcmdldC5wbGF0Zm9ybSxcbiAgICBhcmNoOiB0YXJnZXQuYXJjaCxcbiAgICBwYWNrYWdlZFBhdGg6IG91dHB1dFBhdGhzW2luZGV4XSxcbiAgfSkpO1xufTtcbiJdLCJuYW1lcyI6WyJkIiwiZGVidWciLCJyZXNvbHZlSG9va3MiLCJob29rcyIsImRpciIsIm1hcCIsImhvb2siLCJyZXF1aXJlU2VhcmNoIiwic2VxdWVudGlhbEhvb2tzIiwiYnVpbGRQYXRoIiwiZWxlY3Ryb25WZXJzaW9uIiwicGxhdGZvcm0iLCJhcmNoIiwiZG9uZSIsInByb21pc2lmeSIsImVyciIsInRvU3RyaW5nIiwic2VxdWVudGlhbEZpbmFsaXplUGFja2FnZVRhcmdldHNIb29rcyIsInRhcmdldHMiLCJsaXN0clBhY2thZ2UiLCJwcm92aWRlZERpciIsInByb2Nlc3MiLCJjd2QiLCJpbnRlcmFjdGl2ZSIsImdldEhvc3RBcmNoIiwib3V0RGlyIiwicnVubmVyIiwiTGlzdHIiLCJ0aXRsZSIsInRhc2siLCJjdHgiLCJyZXNvbHZlZERpciIsInJlc29sdmVEaXIiLCJFcnJvciIsImZvcmdlQ29uZmlnIiwiZ2V0Rm9yZ2VDb25maWciLCJwYWNrYWdlSlNPTiIsInJlYWRNdXRhdGVkUGFja2FnZUpzb24iLCJtYWluIiwiY2FsY3VsYXRlZE91dERpciIsImdldEN1cnJlbnRPdXREaXIiLCJuZXdMaXN0ciIsImNoYWxrIiwieWVsbG93IiwiXyIsImdldEhvb2tMaXN0clRhc2tzIiwiZ2V0VGFyZ2V0S2V5IiwidGFyZ2V0Iiwib3V0cHV0IiwicHJvdmlkZVRhcmdldHMiLCJ0YXJnZXRzUHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwic2lnbmFsQ29weURvbmUiLCJNYXAiLCJzaWduYWxSZWJ1aWxkRG9uZSIsInNpZ25hbFBhY2thZ2VEb25lIiwicmVqZWN0cyIsInNpZ25hbERvbmUiLCJnZXQiLCJwb3AiLCJhZGRTaWduYWxBbmRXYWl0IiwidGFyZ2V0S2V5IiwicmVqZWN0IiwicHVzaCIsInNldCIsImNvbmNhdCIsInJlYnVpbGRUYXNrcyIsInNpZ25hbFJlYnVpbGRTdGFydCIsImFmdGVyRmluYWxpemVQYWNrYWdlVGFyZ2V0c0hvb2tzIiwicGFja2FnZXJDb25maWciLCJhZnRlckZpbmFsaXplUGFja2FnZVRhcmdldHMiLCJwcnVuZUVuYWJsZWQiLCJwcnVuZSIsImFmdGVyQ29weUhvb2tzIiwicFBsYXRmb3JtIiwicEFyY2giLCJiaW5zIiwiZ2xvYiIsInBhdGgiLCJqb2luIiwiYmluIiwiZnMiLCJyZW1vdmUiLCJydW5Ib29rIiwibGlzdHJDb21wYXRpYmxlUmVidWlsZEhvb2siLCJyZWJ1aWxkQ29uZmlnIiwiY29waWVkUGFja2FnZUpTT04iLCJjb25maWciLCJmb3JnZSIsIndyaXRlSnNvbiIsInNwYWNlcyIsImFmdGVyQ29weSIsImFmdGVyQ29tcGxldGVIb29rcyIsImFmdGVyUHJ1bmVIb29rcyIsImFmdGVyUHJ1bmUiLCJhZnRlckV4dHJhY3RIb29rcyIsImFmdGVyRXh0cmFjdCIsInBhY2thZ2VPcHRzIiwiYXNhciIsIm92ZXJ3cml0ZSIsImlnbm9yZSIsInF1aWV0IiwiYWZ0ZXJDb21wbGV0ZSIsIm91dCIsImdldEVsZWN0cm9uVmVyc2lvbiIsImFsbCIsInZlcnNpb24iLCJhcHBWZXJzaW9uIiwid2FybiIsInByZWJ1aWx0QXNhciIsInBhY2thZ2VyUHJvbWlzZSIsInBhY2thZ2VyIiwiY2F0Y2giLCJmb3JVbml2ZXJzYWwiLCJjeWFuIiwiZ3JlZW4iLCJvcHRpb25zIiwic2hvd1RpbWVyIiwiaXRhbGljIiwicGVyc2lzdGVudE91dHB1dCIsImJvdHRvbUJhciIsIkluZmluaXR5IiwicmVuZGVyZXJPcHRpb25zIiwiY29sbGFwc2UiLCJjb2xsYXBzZUVycm9ycyIsImNvbmN1cnJlbnQiLCJvdXRwdXRQYXRocyIsInJlbmRlcmVyU2lsZW50IiwicmVuZGVyZXJGYWxsYmFjayIsIkJvb2xlYW4iLCJlbnYiLCJERUJVRyIsImluY2x1ZGVzIiwib3B0cyIsInJ1biIsImluZGV4IiwicGFja2FnZWRQYXRoIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFpQixHQUFNLENBQU4sS0FBTTtBQUNHLEdBQU0sQ0FBTixLQUFNO0FBRStCLEdBQTRCLENBQTVCLFVBQTRCO0FBRS9ELEdBQWUsQ0FBZixJQUFlO0FBQ3pCLEdBQU8sQ0FBUCxNQUFPO0FBQ1AsR0FBTyxDQUFQLE1BQU87QUFDb0UsR0FBbUIsQ0FBbkIsaUJBQW1CO0FBQy9GLEdBQVcsQ0FBWCxTQUFXO0FBQ2IsR0FBVSxDQUFWLFFBQVU7QUFDSCxHQUFRLENBQVIsT0FBUTtBQUVILEdBQXNCLENBQXRCLFlBQXNCO0FBQ04sR0FBYyxDQUFkLEtBQWM7QUFDcEMsR0FBa0IsQ0FBbEIsU0FB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