"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "MakerDebConfig", {
    enumerable: true,
    get: function() {
        return _config.MakerDebConfig;
    }
});
exports.debianArch = debianArch;
exports.MakerDeb = exports.default = void 0;
var _path = _interopRequireDefault(require("path"));
var _makerBase = require("@electron-forge/maker-base");
var _config = require("./Config");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function debianArch(nodeArch) {
    switch(nodeArch){
        case 'ia32':
            return 'i386';
        case 'x64':
            return 'amd64';
        case 'armv7l':
            return 'armhf';
        case 'arm':
            return 'armel';
        default:
            return nodeArch;
    }
}
class MakerDeb extends _makerBase.MakerBase {
    isSupportedOnCurrentPlatform() {
        return this.isInstalled('electron-installer-debian');
    }
    async make({ dir , makeDir , targetArch  }) {
        // eslint-disable-next-line node/no-missing-require
        const installer = require('electron-installer-debian');
        const outDir = _path.default.resolve(makeDir, 'deb', targetArch);
        await this.ensureDirectory(outDir);
        const { packagePaths  } = await installer({
            options: {},
            ...this.config,
            arch: debianArch(targetArch),
            src: dir,
            dest: outDir,
            rename: undefined
        });
        return packagePaths;
    }
    constructor(...args){
        super(...args);
        this.name = 'deb';
        this.defaultPlatforms = [
            'linux'
        ];
        this.requiredExternalBinaries = [
            'dpkg',
            'fakeroot'
        ];
    }
}
exports.default = MakerDeb;
exports.MakerDeb = MakerDeb;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9NYWtlckRlYi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcblxuaW1wb3J0IHsgTWFrZXJCYXNlLCBNYWtlck9wdGlvbnMgfSBmcm9tICdAZWxlY3Ryb24tZm9yZ2UvbWFrZXItYmFzZSc7XG5pbXBvcnQgeyBGb3JnZUFyY2gsIEZvcmdlUGxhdGZvcm0gfSBmcm9tICdAZWxlY3Ryb24tZm9yZ2Uvc2hhcmVkLXR5cGVzJztcblxuaW1wb3J0IHsgTWFrZXJEZWJDb25maWcgfSBmcm9tICcuL0NvbmZpZyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWJpYW5BcmNoKG5vZGVBcmNoOiBGb3JnZUFyY2gpOiBzdHJpbmcge1xuICBzd2l0Y2ggKG5vZGVBcmNoKSB7XG4gICAgY2FzZSAnaWEzMic6XG4gICAgICByZXR1cm4gJ2kzODYnO1xuICAgIGNhc2UgJ3g2NCc6XG4gICAgICByZXR1cm4gJ2FtZDY0JztcbiAgICBjYXNlICdhcm12N2wnOlxuICAgICAgcmV0dXJuICdhcm1oZic7XG4gICAgY2FzZSAnYXJtJzpcbiAgICAgIHJldHVybiAnYXJtZWwnO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbm9kZUFyY2g7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFrZXJEZWIgZXh0ZW5kcyBNYWtlckJhc2U8TWFrZXJEZWJDb25maWc+IHtcbiAgbmFtZSA9ICdkZWInO1xuXG4gIGRlZmF1bHRQbGF0Zm9ybXM6IEZvcmdlUGxhdGZvcm1bXSA9IFsnbGludXgnXTtcblxuICByZXF1aXJlZEV4dGVybmFsQmluYXJpZXM6IHN0cmluZ1tdID0gWydkcGtnJywgJ2Zha2Vyb290J107XG5cbiAgaXNTdXBwb3J0ZWRPbkN1cnJlbnRQbGF0Zm9ybSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc0luc3RhbGxlZCgnZWxlY3Ryb24taW5zdGFsbGVyLWRlYmlhbicpO1xuICB9XG5cbiAgYXN5bmMgbWFrZSh7IGRpciwgbWFrZURpciwgdGFyZ2V0QXJjaCB9OiBNYWtlck9wdGlvbnMpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tbWlzc2luZy1yZXF1aXJlXG4gICAgY29uc3QgaW5zdGFsbGVyID0gcmVxdWlyZSgnZWxlY3Ryb24taW5zdGFsbGVyLWRlYmlhbicpO1xuXG4gICAgY29uc3Qgb3V0RGlyID0gcGF0aC5yZXNvbHZlKG1ha2VEaXIsICdkZWInLCB0YXJnZXRBcmNoKTtcblxuICAgIGF3YWl0IHRoaXMuZW5zdXJlRGlyZWN0b3J5KG91dERpcik7XG4gICAgY29uc3QgeyBwYWNrYWdlUGF0aHMgfSA9IGF3YWl0IGluc3RhbGxlcih7XG4gICAgICBvcHRpb25zOiB7fSxcbiAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgYXJjaDogZGViaWFuQXJjaCh0YXJnZXRBcmNoKSxcbiAgICAgIHNyYzogZGlyLFxuICAgICAgZGVzdDogb3V0RGlyLFxuICAgICAgcmVuYW1lOiB1bmRlZmluZWQsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcGFja2FnZVBhdGhzO1xuICB9XG59XG5cbmV4cG9ydCB7IE1ha2VyRGViLCBNYWtlckRlYkNvbmZpZyB9O1xuIl0sIm5hbWVzIjpbIk1ha2VyRGViQ29uZmlnIiwiZGViaWFuQXJjaCIsIm5vZGVBcmNoIiwiTWFrZXJEZWIiLCJNYWtlckJhc2UiLCJpc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtIiwiaXNJbnN0YWxsZWQiLCJtYWtlIiwiZGlyIiwibWFrZURpciIsInRhcmdldEFyY2giLCJpbnN0YWxsZXIiLCJyZXF1aXJlIiwib3V0RGlyIiwicGF0aCIsInJlc29sdmUiLCJlbnN1cmVEaXJlY3RvcnkiLCJwYWNrYWdlUGF0aHMiLCJvcHRpb25zIiwiY29uZmlnIiwiYXJjaCIsInNyYyIsImRlc3QiLCJyZW5hbWUiLCJ1bmRlZmluZWQiLCJuYW1lIiwiZGVmYXVsdFBsYXRmb3JtcyIsInJlcXVpcmVkRXh0ZXJuYWxCaW5hcmllcyJdLCJtYXBwaW5ncyI6Ijs7OzsrQkFxRG1CQSxDQUFjOzs7ZUFBZEEsT0FBYzs7O1FBOUNqQkMsVUFBVSxHQUFWQSxVQUFVOztBQVBULEdBQU0sQ0FBTixLQUFNO0FBRWlCLEdBQTRCLENBQTVCLFVBQTRCO0FBR3JDLEdBQVUsQ0FBVixPQUFVOzs7Ozs7U0FFekJBLFVBQVUsQ0FBQ0MsUUFBbUIsRUFBVSxDQUFDO0lBQ3ZELE1BQU0sQ0FBRUEsUUFBUTtRQUNkLElBQUksQ0FBQyxDQUFNO1lBQ1QsTUFBTSxDQUFDLENBQU07UUFDZixJQUFJLENBQUMsQ0FBSztZQUNSLE1BQU0sQ0FBQyxDQUFPO1FBQ2hCLElBQUksQ0FBQyxDQUFRO1lBQ1gsTUFBTSxDQUFDLENBQU87UUFDaEIsSUFBSSxDQUFDLENBQUs7WUFDUixNQUFNLENBQUMsQ0FBTzs7WUFFZCxNQUFNLENBQUNBLFFBQVE7O0FBRXJCLENBQUM7TUFFb0JDLFFBQVEsU0FBU0MsVUFBUztJQU83Q0MsNEJBQTRCLEdBQVksQ0FBQztRQUN2QyxNQUFNLENBQUMsSUFBSSxDQUFDQyxXQUFXLENBQUMsQ0FBMkI7SUFDckQsQ0FBQztVQUVLQyxJQUFJLENBQUMsQ0FBQyxDQUFDQyxHQUFHLEdBQUVDLE9BQU8sR0FBRUMsVUFBVSxFQUFlLENBQUMsRUFBcUIsQ0FBQztRQUN6RSxFQUFtRCxBQUFuRCxpREFBbUQ7UUFDbkQsS0FBSyxDQUFDQyxTQUFTLEdBQUdDLE9BQU8sQ0FBQyxDQUEyQjtRQUVyRCxLQUFLLENBQUNDLE1BQU0sR0FBR0MsS0FBSSxTQUFDQyxPQUFPLENBQUNOLE9BQU8sRUFBRSxDQUFLLE1BQUVDLFVBQVU7UUFFdEQsS0FBSyxDQUFDLElBQUksQ0FBQ00sZUFBZSxDQUFDSCxNQUFNO1FBQ2pDLEtBQUssQ0FBQyxDQUFDLENBQUNJLFlBQVksRUFBQyxDQUFDLEdBQUcsS0FBSyxDQUFDTixTQUFTLENBQUMsQ0FBQztZQUN4Q08sT0FBTyxFQUFFLENBQUMsQ0FBQztlQUNSLElBQUksQ0FBQ0MsTUFBTTtZQUNkQyxJQUFJLEVBQUVuQixVQUFVLENBQUNTLFVBQVU7WUFDM0JXLEdBQUcsRUFBRWIsR0FBRztZQUNSYyxJQUFJLEVBQUVULE1BQU07WUFDWlUsTUFBTSxFQUFFQyxTQUFTO1FBQ25CLENBQUM7UUFFRCxNQUFNLENBQUNQLFlBQVk7SUFDckIsQ0FBQzs7O1FBNUJZLElBNkJkLENBNUJDUSxJQUFJLEdBQUcsQ0FBSztRQURDLElBNkJkLENBMUJDQyxnQkFBZ0IsR0FBb0IsQ0FBQztZQUFBLENBQU87UUFBQSxDQUFDO1FBSGhDLElBNkJkLENBeEJDQyx3QkFBd0IsR0FBYSxDQUFDO1lBQUEsQ0FBTTtZQUFFLENBQVU7UUFBQSxDQUFDOzs7a0JBTHRDeEIsUUFBUTtRQStCcEJBLFFBQVEsR0FBUkEsUUFBUSJ9